<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>eclipse</title>
<meta name="description" content="Soda Music Computer" />
<link rel="shortcut icon" href="https://eclipse-yes.github.io/favicon.ico?v=1653911914773">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://eclipse-yes.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://eclipse-yes.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://eclipse-yes.github.io/images/avatar.png?v=1653911914773" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">eclipse</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            Table of Contents
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#%E6%95%B0%E7%BB%84%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">数组：买卖股票的最佳时机</a></li>
<li><a href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2">无重复字符的最长子串</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%B8%8D%E6%AD%BB%E7%A5%9E%E5%85%94%E9%97%AE%E9%A2%98">函数：不死神兔问题</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%BF%BB%E8%BD%AC">数组元素翻转</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E8%B5%B0%E8%BF%87%E7%9A%84%E8%B7%AF%E7%A8%8B%E5%92%8C%E5%8F%8D%E5%BC%B9%E9%AB%98%E5%BA%A6">计算走过的路程和反弹高度</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">指针：合并两个有序链表</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2">指针：验证回文串</a></li>
<li><a href="#%E6%94%BE%E5%A4%A7%E4%BD%8D%E5%9B%BE">放大位图</a></li>
<li><a href="#%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E7%94%A8%E6%88%B7">批量注册用户</a></li>
<li><a href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89">类与对象的定义</a></li>
<li><a href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9">类和对象：删除链表的重复节点</a></li>
<li><a href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">类和对象：运算符重载</a></li>
<li><a href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84">类和对象：对象数组</a></li>
<li><a href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%A4%9A%E7%BB%A7%E6%89%BF">类和对象：多继承</a></li>
<li><a href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F">类和对象：继承与派生</a></li>
<li><a href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%83%E4%B9%A0">重载运算符练习</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF%E7%BB%84%E5%90%88">继承组合</a></li>
<li><a href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF">多重继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81%E6%80%A7">多态性</a></li>
<li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0">虚函数</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2a">字符串A</a></li>
<li><a href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1b">类和对象B</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">数组排序</a></li>
<li><a href="#%E9%99%84%E5%8A%A0%E9%A2%98">附加题</a></li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          Home
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.2s">
          Tags
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.4s">
          Archives
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          Whoami
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://eclipse-yes.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">NKUCS OJ Problems: 	Advanced Language Programming</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2022-03-22 / 45 min read
        </div>
        
        <div class="post-content yue">
          <h1 id="数组买卖股票的最佳时机">数组：买卖股票的最佳时机</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

# 样例输入输出
样例1
输入:
7 1 5 3 6 4
输出:
5
样例2
输入:
7 6 4 3 1
输出:
0
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using std::cout; using std::cin; using std::endl;
using std::vector;

class Solution {
public:
    void run() {
        vector&lt;int&gt; prices;
        int prc;
        while (cin &gt;&gt; prc) {
            prices.push_back(prc);
        }

        int maxProfit = 0, minPrc = prices[0];
        for (auto i = prices.begin(); i != prices.end(); ++i) {
            if (*i &gt; minPrc)
                maxProfit = std::max(maxProfit, *i - minPrc);
            else
                minPrc = *i;
        }
        cout &lt;&lt; maxProfit;
    }
};

int main() {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="无重复字符的最长子串">无重复字符的最长子串</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。
s由英文字母，符号，数字组成。

解释：
输入：s = ”abcabcbb”
输出：3
因为无重复字符的最长子串是“abc”，所以其长度为3

# 样例输入输出
样例
输入:
pwwkew
输出:
3
样例2
输入:
aaaa
输出:
1
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using std::cout; using std::cin; using std::endl;
using std::string; using std::map;

class Solution {
public:
    void run() {
        string str; cin &gt;&gt; str;
        map&lt;char, int&gt; dic;
        int maxLen = 0, left = 0;
        for (int i = 0; i &lt; (int)str.size(); ++i) {
            if (dic.find(str[i]) == dic.end() || dic[str[i]] &lt; left) {
                // If dic doesn't have a key of str[i],
                // insert it into dic and maxLen++.
                dic[str[i]] = i;
            }
            else {
                // If dic does have a key of str[i],
                // update left (=dic[str[i]]+1) and maxLen (=i-left+1).
                left = dic[str[i]] + 1;
                dic[str[i]] = i;
            }
            maxLen = std::max(maxLen, i - left +1);
        }
        cout &lt;&lt; maxLen;
    }
};

int main() {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="函数不死神兔问题">函数：不死神兔问题</h1>
<pre><code class="language-Markdown"># 题目描述
有一对兔子，从出生后第 3 个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问第 n 个月的兔子对数为多少？
输入描述：键盘输入任意一个正整数 n，n 的范围为 [1, 20]
输出描述：输出第 n 个月兔子的对数  

# 样例输入输出
样例1
输入:
1
输出:
1
样例2
输入:
2
输出:
1
样例3
输入:
3
输出:
2
样例4
输入:
4
输出:
3
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    void run() {
        int month; cin &gt;&gt; month;
        int a = 0, b = 1;
        while (month &gt; 1) {
            int tmp = a;
            a = b;
            b += tmp;
            --month;
        }
        cout &lt;&lt; b;
    }
};

int main() {
    Solution().run();
    return 0;
}
</code></pre>
<h1 id="数组元素翻转">数组元素翻转</h1>
<pre><code class="language-Markdown"># 题目描述
键盘随机输入 n 个整数，将这些数据保存到数组中，然后再将数组元素反转，按照格式输出数组元素。

输入描述：键盘随机输入 n 个整数输出描述：
输出描述：按照格式输出反转后数组中元素，每个元素中间使用逗号和空格隔开，整体使用中括号括起来。
例如：[60, 15, 7, 80, 12, 5]

# 样例输入输出
样例1
输入:
5 12 80 7 15 60
输出:
[60, 15, 7, 80, 12, 5]
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        vector&lt;int&gt; vec;
        int tmp;
        while (cin &gt;&gt; tmp) {
            vec.push_back(tmp);
        }
        reverse(vec.begin(), vec.end());
        for (int i = 0; i &lt; vec.size(); ++i) {
            if (i == 0) cout &lt;&lt; &quot;[&quot;;
            cout &lt;&lt; vec[i];
            if (i == vec.size()-1) cout &lt;&lt; &quot;]&quot;;
            else cout &lt;&lt;  &quot;, &quot;;
        }
    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="计算走过的路程和反弹高度">计算走过的路程和反弹高度</h1>
<pre><code class="language-Markdown"># 题目描述
一个小球从 h 米高度自由落下，每次落地后反跳回原高度的一半再落下，求它在第 n 次落地时共经过了多少米？第 n 次返弹多高？
输入描述：输入小球下落的高度h(double型)和落地的次数n(int型)（先输入小球初始高度再输入反弹次数）
输出描述：输出小球第 n 次落地时经过的距离和第 n 次反弹的高度（保留小数点后1位）  

# 样例输入输出
样例1
输入:
100 1
输出:
100.0 50.0
样例2
输入:
100.0 3
输出:
250.0 12.5
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        double h; int n; cin &gt;&gt; h &gt;&gt; n;
        double height = h/2, sum = h;
        for (int i = 1; i &lt; n; ++i) {
            sum += height * 2;
            height /= 2;
        }
        printf(&quot;%.1f %.1f&quot;, sum, height);
    }
};

int main() {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="指针合并两个有序链表">指针：合并两个有序链表</h1>
<pre><code class="language-Markdown"># 题目描述
给定两个有序数值数组，要求先按所给数值建立两个链表，链表为升序链表。将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

需要按以下结构体建立链表
struct ListNode {
int val;
ListNode *next;
ListNode(int x) : val(x), next(NULL) {}
};

输入：l1=[1,2,3],l2 = [1,3,4]
输出：[1，1，2，3，4，4]

提示：输入输出的标准模式请见样例输入输出，输入时可以通过两个while循环构造两个链表，其中一行为一个链表，判断当遇到‘\n’时结束循环，链表构造完成。
提示：输出的最后一个数字后无“ ”

# 样例输入输出
样例1
输入:
1 2 4
1 3 4
输出:
1 1 2 3 4 4
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct ListNode {
    int val;
    ListNode *next;
    ListNode(): val(0), next(nullptr) {}
    ListNode(int x, ListNode* next= nullptr) : val(x), next(next) {}
} ListNode;

class Solution {
public:
    static void run() {
        // Handle input stream.
        string str, strNum;
        getline(cin, str);
        stringstream ss(str);
        vector&lt;int&gt; vec1, vec2;
        while (getline(ss, strNum, ' '))  // Let vec1 store elements of list1.
            vec1.push_back(stoi(strNum));
        getline(cin, str);
        stringstream ss2(str);
        while (getline(ss2, strNum, ' '))  // Let vec2 store elements of list2.
            vec2.push_back(stoi(strNum));

        // Initialize two linked lists.
        ListNode list1[vec1.size()];
        ListNode list2[vec2.size()];
        for (int i = 0; i &lt; vec1.size(); ++i)
            list1[i] = ListNode(vec1[i]);
        for (int i = 0; i &lt; vec1.size() - 1; ++i)
            list1[i].next = &amp;list1[i+1];
        for (int i = 0; i &lt; vec2.size(); ++i)
            list2[i] = ListNode(vec2[i]);
        for (int i = 0; i &lt; vec2.size() - 1; ++i)
            list2[i].next = &amp;list2[i+1];

        // Combine two linked lists;
        ListNode* p1 = &amp;list1[0]; ListNode* p2 = &amp;list2[0];
        auto head = ListNode(-1); ListNode* p3 = &amp;head;
        while (p1 &amp;&amp; p2) {
            if (p1-&gt;val &lt;= p2-&gt;val) { p3-&gt;next = p1; p1 = p1-&gt;next; p3 = p3-&gt;next; }
            else { p3-&gt;next = p2; p2 = p2-&gt;next; p3 = p3-&gt;next; }
        }
        if (p1) p3-&gt;next = p1;
        if (p2) p3-&gt;next = p2;

        ListNode* res = (&amp;head)-&gt;next;
        for (; res; res = res-&gt;next)
            { cout &lt;&lt; res-&gt;val; if (res-&gt;next) cout &lt;&lt; &quot; &quot;; }

    }
};


int main () {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="指针验证回文串">指针：验证回文串</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个字符串，验证它是否是回文串，回文字符串就是正向和反向看完全相同的字符串，只考虑字母和数字字符，不考虑标点符号，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。

示例 :
输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
解释：&quot;amanaplanacanalpanama&quot; 是回文串
示例 :
输入: &quot;race a car&quot;
输出: false
解释：&quot;raceacar&quot; 不是回文串

提示：可以先对字符串进行处理，去除标点符号将大写字母全部转换为小写

# 样例输入输出
样例1
输入:
A man, a plan, a canal: Panama
输出:
true
样例2
输入:
race a car
输出:
false
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        string str; cin &gt;&gt; str;
        // Handle the input string.
        for (auto i = str.begin(); i != str.end(); ) {
            if (!isalpha(*i)) { i = str.erase(i); continue; }
            if (isupper(*i)) *i = static_cast&lt;char&gt;(tolower(*i));
            i = i + 1;
        }

        // Judge whether str is palindrome or not.
        for (int i = 0, j = static_cast&lt;int&gt;(str.size()) - 1; i != j &amp;&amp; i - 1 != j ; ++i, --j) {
            if (str[i] == str[j]) continue;
            else { cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; return; }
        }
        cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;
    }
};

int main () {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="放大位图">放大位图</h1>
<pre><code class="language-Markdown"># 题目描述
位图（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。然而，如果从稍远的位置观看它，位图图像的颜色和形状又显得是连续的。
现在请你设计一个程序将原来n*n的图像放大k倍。

例如，将2*2的点阵放大2倍
1	0
0	1
经过放大后新的点阵为
1	1	0	0
1	1	0	0
0	0	1	1
0	0	1	1
输出样例的每个数字后用空格隔开

# 样例输入输出
样例1
输入:
2 2
1 0
0 1
输出:
1 1 0 0
1 1 0 0
0 0 1 1
0 0 1 1
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        int n, k; cin &gt;&gt; n &gt;&gt; k;
        vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n));
        vector&lt;vector&lt;int&gt;&gt; ret;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++)
                cin &gt;&gt; matrix[i][j];
        }

        for (int i = 0; i &lt; n; i++) {
            vector&lt;int&gt; tmp(n * k);
            for (int j = 0; j &lt; n; j++) {
                for (int kk = 0; kk &lt; k; kk++) {
                    tmp[j * k + kk] = matrix[i][j];
                }
            }
            for (int kk = 0; kk &lt; k; kk++)
                ret.push_back(tmp);
        }
        for (const auto &amp; vec : ret) {
            for (const auto &amp; i : vec)
                cout &lt;&lt; i &lt;&lt; &quot; &quot;;
            cout &lt;&lt; endl;
        }
    }
};

int main () {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="批量注册用户">批量注册用户</h1>
<pre><code class="language-Markdown"># 题目描述
小明想要尝试注册多个用户名，用户名的规则如下：
用户名长度不能少于6位，不能多于12位；用户名必须由字母（大小写均可）构成；同一个用户名不能被重复注册；
请你编写一个程序判断小明的n个用户名是否创建成功。
如果创建成功输出：registration complete。
如果长度不合法输出：illegal length。
若长度不合法且字符也不合法输出：illegal length。
如果字符不合法输出：illegal charactor。
如果用户名已存在输出：acount existed。

# 样例输入输出
样例1
输入:
5
1
abcd
abcdef
abcdef
abc1ef
输出:
illegal length
illegal length
registration complete
acount existed
illegal charactor
</code></pre>
<p>只要长度不合法 -&gt; illegal length<br>
长度合法 但是字符不合法 -&gt; illegal charactor<br>
用户名存在 -&gt; acount existed</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        int n; cin &gt;&gt; n;
        vector&lt;string&gt; inputStr(n);
        set&lt;string&gt; st;
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; inputStr[i];

        for (int i = 0; i &lt; n; i++) {
            if (inputStr[i].size() &lt; 6 || inputStr[i].size() &gt; 12) { cout &lt;&lt; &quot;illegal length&quot; &lt;&lt; endl; continue; }
            bool flag = false;
            for (const auto &amp; chr : inputStr[i]) {
                if ((chr &gt;= 'a' &amp;&amp; chr &lt;= 'z') || (chr &gt;= 'A' &amp;&amp; chr &lt;= 'Z'))
                    continue;
                cout &lt;&lt; &quot;illegal charactor&quot; &lt;&lt; endl; flag = true; break;
            }
            if (flag) continue;
            if (st.find(inputStr[i]) == st.end()) { cout &lt;&lt; &quot;registration complete&quot; &lt;&lt; endl; st.insert(inputStr[i]); }
            else cout &lt;&lt; &quot;acount existed&quot; &lt;&lt; endl;
        }
    }
};

int main () {
    Solution::run();
    return 0;
}
</code></pre>
<h1 id="类与对象的定义">类与对象的定义</h1>
<pre><code class="language-Markdown"># 题目描述
要求设计一个立方体类（Cube）

成员变量有：长（length）、宽（width）、高（height），都为int类型；

成员方法有：输入输出函数、获取表面积的方法（getArea），获取体积的方法（getVolume）。

输入描述：输入立方体的长、宽、高

输出描述：输出立方体的长、宽、高、面积、体积

要求：长宽高均为整数类型，输入/输出的各项之间使用空格隔开。

# 样例输入输出
样例1
输入:
3 4 5
输出:
3 4 5 94 60
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Cube {
private:
    int length, width, height;

public:
    void Input() {
        cin &gt;&gt; length &gt;&gt; width &gt;&gt; height;
    }

    int getArea() {
        return (length * width + width * height + height * length) * 2;
    }

    int getVolume() {
        return length * width * height;
    }

    void Output() {
        cout &lt;&lt; length &lt;&lt; &quot; &quot; &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; &quot; &quot; &lt;&lt; getArea() &lt;&lt; &quot; &quot; &lt;&lt; getVolume() &lt;&lt; endl;
    }
};

int main () {
    auto cube = Cube();
    cube.Input();
    cube.Output();
    return 0;
}
</code></pre>
<h1 id="类和对象删除链表的重复节点">类和对象：删除链表的重复节点</h1>
<pre><code class="language-Markdown"># 题目描述
给定一个随机长度的数值数组，要求构造成链表并删除其中有重复的元素，使每个元素只出现一次。返回删除好的链表。按输入顺序，删除第一次之后出现的结点，按原顺序返回

输入描述：输入一系列数值，不一定有序

输出描述：删除重复结点后的链表。

# 样例输入输出
样例1
输入:
1 5 3 1 9
输出:
1 5 3 9
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct Node {
    int val;
    Node * next;
    Node(int x) : val(x), next(nullptr) {}
    Node(int x, Node * n) : val(x), next(n) {}
} Node;

class Solution {
private:
    set&lt;int&gt; se;

public:
    void Run() {
        // Prepare numbers of link list.
        string str; getline(cin, str);
        stringstream ss(str);
        string subStr;
        vector&lt;int&gt; vec;
        while (getline(ss, subStr, ' '))
            vec.push_back(stoi(subStr));

        // Use set to erase repeated elements.
        Node * head = new Node(-1);
        Node * p = head;
        for (const auto &amp; i : vec) {
            if (se.find(i) != se.end()) continue;
            se.insert(i);
            p-&gt;next = new Node(i);
            p = p-&gt;next;
        }
        for (Node * i = head; i-&gt;next != nullptr; i = i-&gt;next)
            cout &lt;&lt; i-&gt;next-&gt;val &lt;&lt; &quot; &quot;;
    }
};

int main () {
    Solution().Run();
    return 0;
}
</code></pre>
<h1 id="类和对象运算符重载">类和对象：运算符重载</h1>
<pre><code class="language-Markdown"># 题目描述
定义一个日期类Date，包含年、月、日三个数据成员，请实现重载自增运算符（++），实现日期的自增。

输入描述：2020 11 11，对应年，月，日
输出描述：2020 年11月12日，对应明天的年，月，日
需要注意特殊情况比如（月末，年末，平年，闰年判断）例如：
输入：2020 12 31
输出：2021年1月1日

# 样例输入输出
样例1
输入:
2021 12 11
输出:
2021年12月12日
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Date {
private:
    int year;
    int month;
    int day;
    vector&lt;int&gt; mon30 = {4, 6, 9, 11};
    vector&lt;int&gt; mon31 = {1, 3, 5, 7, 8, 10};

    void dateCheck() {
        // Special Case: 2月份 闰年 平年
        if (month == 2) {
            if ((year % 100 == 0 &amp;&amp; year % 400 == 0) || (year % 4 == 0)) {
                if (day &gt; 29) { month++; day %= 29; return; }
            } else {
                if (day &gt; 28) { month++; day %= 28; return; }
            }
        }
        // Special Case: 31天的月份 30天的月份
        if (month == 12) {
            if (day &gt; 31) { year++; month = 1; day %= 31; return; }
        }
        if (find(mon30.begin(), mon30.end(), month) != mon30.end()) {
            if (day &gt; 30) { month++; day %= 30; return; }
        }
        if (find(mon31.begin(), mon31.end(), month) != mon31.end()) {
            if (day &gt; 31) { month++; day %= 31; return; }
        }
    }

public:
    Date(int y, int m, int d) : year(y), month(m), day(d) {}

    void operator++(int) {
        day++;
        dateCheck();
    }

    void Print() const {
        cout &lt;&lt; year &lt;&lt; &quot;年&quot; &lt;&lt; month &lt;&lt; &quot;月&quot; &lt;&lt; day &lt;&lt; &quot;日&quot; &lt;&lt; endl;
    }
};

int main() {
    int y, m, d; cin &gt;&gt; y &gt;&gt; m &gt;&gt; d;
    Date dt = Date(y, m, d);
    dt++;
    dt.Print();

    return 0;
}
</code></pre>
<h1 id="类和对象对象数组">类和对象：对象数组</h1>
<pre><code class="language-Markdown"># 题目描述
构建一个Book类，有4个私有数据成员：书名、作者、qu和price（均为int型），将qu进行初始化，
同时price被始化为qu的10倍。建立一个有5个元素的对象数组，顺序显示每个对象数组中元素的信息；
定义对象指针，通过指针访问对象数组，逆序显示对象数组中元素的信息。书名、作者、qu的信息从键盘输入

输入描述： 5个对象数组元素的值 
输出描述： 顺序显示对象数组中各对象的值 ，各参数中间以空格隔开
				 逆序显示对象数组中各对象的值 ，各参数中间以空格隔开

# 样例输入输出
## 样例1
输入:
C语言程序设计 苏小红 2
C++程序设计 刘丽华 3
Python机器学习 范淼 4
数据结构与算法 徐凤生 3
大话数据结构 程杰 2
输出:
书名：C语言程序设计 作者：苏小红 价格：20
书名：C++程序设计 作者：刘丽华 价格：30
书名：Python机器学习 作者：范淼 价格：40
书名：数据结构与算法 作者：徐凤生 价格：30
书名：大话数据结构 作者：程杰 价格：20
使用指针逆序显示的结果为
书名：大话数据结构 作者：程杰 价格：20
书名：数据结构与算法 作者：徐凤生 价格：30
书名：Python机器学习 作者：范淼 价格：40
书名：C++程序设计 作者：刘丽华 价格：30
书名：C语言程序设计 作者：苏小红 价格：20
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Book {
private:
    string name;
    string author;
    int qu;
    int price;

public:
    Book(string nm, string auth, int qu) : name(std::move(nm)), author(std::move(auth)), qu(qu), price(qu*10) {}

    void Print() const {
        cout &lt;&lt; &quot;书名：&quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; &quot;作者：&quot; &lt;&lt; author &lt;&lt; &quot; &quot; &lt;&lt; &quot;价格：&quot; &lt;&lt; price &lt;&lt; endl;
    }
};

int main() {
    vector&lt;Book&gt; books;
    for (int i = 0; i &lt; 5; i++) {
        string name;
        string author;
        int qu;
        cin &gt;&gt; name &gt;&gt; author &gt;&gt; qu;
        books.emplace_back(name, author, qu);
    }

    // Print out 5 books.
    for (const auto &amp; book : books)
        book.Print();
    reverse(books.begin(), books.end());
    cout &lt;&lt; &quot;使用指针逆序显示的结果为&quot; &lt;&lt;  endl;
    for (const auto &amp; book : books)
        book.Print();

    return 0;
}
</code></pre>
<h1 id="类和对象多继承">类和对象：多继承</h1>
<pre><code class="language-Markdown"># 题目描述
1、定义日期“Date”类，类中包含数据成员年、月、日，成员函数包括构造函数（只有带参的构造函数），设置日期函数，显示日期函数
2、定义时间“Time”类，数据成员包括时、分、秒。成员函数的要求与date类相同
3、定义日期时间型“Date_Time”类
⑴公有继承Date类及Time类；
⑵不增加数据成员；
⑶增加日期时间处理成员函数，包括初始化日期时间、设置日期时间、显示日期时间等。
4、每个类都要求重载&gt;&gt; 和&lt;&lt;运算符用于对日期时间的输入和输出
5.对Date_Time，重载&gt;运算符，用于判断两个时间大小。
6. 编写main()函数进行测试。在主函数中，输入两个Date_Time类的数据，对两个日期时间进行比较，输出较小的一个。

# 样例输入输出
样例1
输入:
2022 4 16 18 30 31 2022 4 16 18 30 35
输出:
2022-4-16 18:30:31
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Date {
public:
    int year;
    int month;
    int day;

public:
    Date(int y, int m, int d) : year(y), month(m), day(d) {};

    friend ostream &amp; operator&lt;&lt;(ostream &amp; output, const Date &amp; date) {
        output &lt;&lt; to_string(date.year) + &quot;-&quot; + to_string(date.month) + &quot;-&quot; + to_string(date.day);
        return output;
    }

    friend istream &amp; operator&gt;&gt;(istream &amp; input, Date &amp; date) {
        input &gt;&gt; date.year &gt;&gt; date.month &gt;&gt; date.day;
        return input;
    }
};

class Time {
public:
    int hour;
    int minute;
    int second;

public:
    Time(int h, int m, int s) : hour(h), minute(m), second(s) {};

    friend ostream &amp; operator&lt;&lt;(ostream &amp; output, const Time &amp; time) {
        output &lt;&lt; to_string(time.hour) + &quot;:&quot; + to_string(time.minute) + &quot;:&quot; + to_string(time.second);
        return output;
    }

    friend istream &amp; operator&gt;&gt;(istream &amp; input, Time &amp; time) {
        input &gt;&gt; time.hour &gt;&gt; time.minute &gt;&gt; time.second;
        return input;
    }
};

class Date_Time : public Date, public Time {
public:
    Date_Time() : Date(0, 0, 0), Time(0, 0, 0) {}
    Date_Time(int y, int m, int d, int h, int min, int s) : Date(y, m, d), Time(h, min, s) {}

    friend ostream &amp; operator&lt;&lt;(ostream &amp; output, const Date_Time &amp; dateTime) {
        output &lt;&lt; to_string(dateTime.year) + &quot;-&quot; + to_string(dateTime.month) + &quot;-&quot; + to_string(dateTime.day);
        output &lt;&lt; &quot; &quot;;
        output &lt;&lt; to_string(dateTime.hour) + &quot;:&quot; + to_string(dateTime.minute) + &quot;:&quot; + to_string(dateTime.second);
        return output;
    }

    friend istream &amp; operator&gt;&gt;(istream &amp; input, Date_Time &amp; dateTime) {
        input &gt;&gt; dateTime.year &gt;&gt; dateTime.month &gt;&gt; dateTime.day;
        input &gt;&gt; dateTime.hour &gt;&gt; dateTime.minute &gt;&gt; dateTime.second;
        return input;
    }

    bool operator&gt;(Date_Time &amp; time2) {
        if (this-&gt;year &lt; time2.year) return false;
        else if (this-&gt;year &gt; time2.year) return true;
        if (this-&gt;month &lt; time2.month) return false;
        else if (this-&gt;month &gt; time2.month) return true;
        if (this-&gt;day &lt; time2.day) return false;
        else if (this-&gt;day &gt; time2.day) return true;
        if (this-&gt;hour &lt; time2.hour) return false;
        else if (this-&gt;hour &gt; time2.hour) return true;
        if (this-&gt;minute &lt; time2.minute) return false;
        else if (this-&gt;minute &gt; time2.minute) return true;
        if (this-&gt;second &lt; time2.second) return false;
        else if (this-&gt;second &gt; time2.second) return true;
        return false;
    }
};

int main() {
    Date_Time dateTime1, dateTime2;
    cin &gt;&gt; dateTime1 &gt;&gt; dateTime2;
    if (dateTime1 &gt; dateTime2)
        cout &lt;&lt; dateTime2;
    else
        cout &lt;&lt; dateTime1;
    return 0;
}
</code></pre>
<h1 id="类和对象继承与派生">类和对象：继承与派生</h1>
<pre><code class="language-Markdown"># 题目描述
把描述直角坐标系上的一个点类作为基类，派生出描述一条直线的类和描述一个三角形的类。定义成员函数求出两点间的距离和三角形的面积。点的坐标均为int型
提示：先定义描述点 的类Point；类Line继承自Point类，一个直线有两个端点，所以他在点类的基础上新增一组点的坐标（x2，y2）；三角形类 Triangle  再直线的基础上再新增一组点的坐标（x3，y3）求出三角形的面积。具体要求如下
（1）定义点类Point
保护数据成员 x1，y1
共有构造函数Point（int x1，int  y1）用于初始化x1，y1
（2）定义直线类Line
保护数据成员x2，y2
共有构造函数Line （ int x1，int  y1 ，int x2，int y2）用于初始化x2，y2，以及父类x1，y1
（3）定义三角形Triangle
私有数据成员 x3，y3
私有数据成员 area
共有构造函数Triangle（ int x1，int  y1 ，int x2，int y2，int x3 ，int y3） 用于初始化x3，y3 以及父类x1，y1，x2，y2
void area（）：求三角形面积的功能函数
void print（）：输出三个点的坐标和面积

输入描述：输入6个int型数值（x1，y1，x2，y2，x3，y3）
输出描述：第一行输出三个点的坐标，第二行输出面积

# 样例输入输出
样例1
输入:
1 1 4 1 4 5
输出:
(1,1)(4,1)(4,5)
6
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Point {
protected:
    int x1, y1;

public:
    Point(int x, int y) : x1(x), y1(y) {}
};

class Line : protected Point {
protected:
    int x2, y2;

public:
    Line(int x1, int y1, int x2, int y2) : Point(x1, y1), x2(x2), y2(y2) {}
};

class Triangle : private Line {
private:
    int x3, y3;
    double area;

public:
    Triangle(int x1, int y1, int x2, int y2, int x3, int y3) : Line(x1, y1, x2, y2), x3(x3), y3(y3), area(0) {}

    void calcArea() {
        area = abs((x1*y2 - x2*y1) + (x2*y3 - x3*y2) + (x3*y1 - x1*y3)) / 2.0;
    }

    void print() {
        cout &lt;&lt; &quot;(&quot; + to_string(x1) + &quot;,&quot; + to_string(y1) + &quot;)&quot;;
        cout &lt;&lt; &quot;(&quot; + to_string(x2) + &quot;,&quot; + to_string(y2) + &quot;)&quot;;
        cout &lt;&lt; &quot;(&quot; + to_string(x3) + &quot;,&quot; + to_string(y3) + &quot;)&quot; &lt;&lt; endl;
        cout &lt;&lt; area &lt;&lt; endl;
    }
};

int main() {
    int x1, y1, x2, y2, x3, y3;
    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3;
    auto triangle = Triangle(x1, y1, x2, y2, x3, y3);
    triangle.calcArea();
    triangle.print();
    return 0;
}
</code></pre>
<h1 id="重载运算符练习">重载运算符练习</h1>
<pre><code class="language-Markdown"># 题目描述
定义一个RMB类Money，包括元角分三个数据成员，重载运算符'+'和'-',实现货币的加减运算。

# 例如：
输入一组元角分：
2 3 4
3 7 3
输出：
和:6元0角7分
差:-1元3角9分
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class RMB {
protected:
    int money;

public:
    explicit RMB(int mon) : money(mon) {}

    RMB operator+(const RMB &amp; rmb) const {
        auto ret = RMB(money + rmb.money);
        return ret;
    }

    RMB operator-(const RMB &amp; rmb) const {
        auto ret = RMB(money - rmb.money);
        return ret;
    }

    void print() const {
        if (money &gt;= 0)
            cout &lt;&lt; money / 100 &lt;&lt; &quot;元&quot; &lt;&lt; (money % 100) / 10 &lt;&lt; &quot;角&quot; &lt;&lt; money % 10 &lt;&lt; &quot;分&quot;;
        else {
            int monTemp = -money;
            cout &lt;&lt; &quot;-&quot; &lt;&lt; monTemp / 100 &lt;&lt; &quot;元&quot; &lt;&lt; (monTemp % 100) / 10 &lt;&lt; &quot;角&quot; &lt;&lt; monTemp % 10 &lt;&lt; &quot;分&quot;;
        }
    }
};

int main() {
    int a, b, c;
    vector&lt;RMB&gt; rmbs;
    for (int i = 0; i &lt; 2; i++) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        rmbs.emplace_back(RMB(a*100 + b*10 + c));
    }
    auto res1 = rmbs[0] + rmbs[1];
    auto res2 = rmbs[0] - rmbs[1];
    cout &lt;&lt; &quot;和:&quot;; res1.print(); cout &lt;&lt; endl;
    cout &lt;&lt; &quot;差:&quot;; res2.print(); cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<h1 id="继承">继承</h1>
<pre><code class="language-Markdown"># 题目描述
以点（Point）类为基类，重新定义圆类（Circle）。在圆类中实现一个 isPointerInCircle方法，该方法传入一个点类对象，判断点和圆的关系，并在该方法中输出。

点类（Point）:
        成员变量：x轴坐标（int x）  y轴坐标（int y）
圆类（Circle）继承自点类（Point），以Point为圆心:
        成员变量： 半径（double radius）
        成员方法：判断点和圆关系的方法（isPointerInCircle）
点和圆的关系（最终输出为以下三种关系之一）：
        点在圆外
        点在圆上
        点在圆内

输入描述：
0 0
1 1 1.0
（第一行为要判断的点的横纵坐标，第二行前两个参数为圆的圆心坐标，第三个参数为圆的半径）
输出描述：
点在圆外

# 样例输入输出
样例1
输入:
0 0
1 1 1.0
输出:
点在圆外
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Point {
public:
    int x;
    int y;
    Point(int a, int b) : x(a), y(b) {}
};

class Circle : public Point {
public:
    double radius;

public:
    Circle(int a, int b, double c) : Point(a, b), radius(c) {}

    void isPointerInCircle(const Point &amp; p) const {
        double distance = sqrt(pow(fabs(x - p.x), 2) + pow(fabs(y - p.y), 2));
        if (distance - radius &gt; DBL_EPSILON)
            cout &lt;&lt; &quot;点在圆外&quot;;
        else if (distance - radius &gt;= 0 &amp;&amp; distance - radius &lt;= DBL_EPSILON)
            cout &lt;&lt; &quot;点在圆上&quot;;
        else
            cout &lt;&lt; &quot;点在圆内&quot;;
    }
};

int main() {
    int pX, pY; cin &gt;&gt; pX &gt;&gt; pY; auto p = Point(pX, pY);
    double r; cin &gt;&gt; pX &gt;&gt; pY &gt;&gt; r; auto circle = Circle(pX, pY, r);
    circle.isPointerInCircle(p);
    return 0;
}
</code></pre>
<h1 id="继承组合">继承组合</h1>
<pre><code class="language-Markdown"># 题目描述
声明Teacher（教师）类为基类，数据成员包括：姓名，性别。成员函数为构造析构函数
Professor（教授）类为Teacher类的派生类。
另有一个BirthDate（生日）类，数据成员包含year，month，day等数据成员。可以将教授的生日信息加入到Professor类的声明中作为Professor的对象成员。
在主函数中，定义Professor类对象时给定初始值，然后给定一个新的BirthDate类对象，更新原对象中的生日数据并输出。

输入描述：
第一行依次输入构造Professor对象的各项初始数据
第二行输入为新的BirthDate对象的数值
输出描述
更新原有的professor对象的birthday数据并输出

# 样例输入输出
样例1
输入:
zhangsan M 1999 7 14
2001 5 21
输出:
name: zhangsan
sex: M
birthdate: 2001/5/21
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Teacher {
public:
    string name;
    string gender;

public:
    Teacher(string &amp; n, string &amp; g) : name(n), gender(g) {}
};

class BirthDate {
public:
    int year;
    int month;
    int day;
    BirthDate(int y, int m, int d) : year(y), month(m), day(d) {}
};

class Professor : public Teacher {
public:
    BirthDate bd;
    Professor(string &amp; n, string &amp; g, int y, int m, int d) :
            Teacher(n, g), bd(BirthDate(y, m, d)) {}

    void print() const {
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; &quot;sex: &quot;  &lt;&lt; gender &lt;&lt; endl;
        cout &lt;&lt; &quot;birthdate: &quot; &lt;&lt; bd.year &lt;&lt; &quot;/&quot; &lt;&lt; bd.month &lt;&lt; &quot;/&quot; &lt;&lt; bd.day &lt;&lt; endl;
    }
};

int main() {
    string n, g; int y, m, d;
    cin &gt;&gt; n &gt;&gt; g &gt;&gt; y &gt;&gt; m &gt;&gt; d; auto prof = Professor(n, g, y, m, d);
    cin &gt;&gt; y &gt;&gt; m &gt;&gt; d; prof.bd = BirthDate(y, m, d);
    prof.print();
    return 0;
}
</code></pre>
<h1 id="多重继承">多重继承</h1>
<pre><code class="language-Markdown"># 题目描述
分别定义Teacher(教师）类和Cadre（干部）类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类。要求：
1、Teacher类中包含数据成员 姓名、年龄、性别、职称（title）。
2、Cadre类中包含数据成员 姓名、年龄、性别、职务（post）。
3、Teacher_Cadre类中还包含数据成员工资（wages）。
4.两个基类中的姓名、年龄、性别 数据成员用相同的名字，在引用这些数据成员时，指定作用域。
5、在派生类Teacher_Cadre 的成员函数show 中调用Teacher类中的display 函数,输出姓名、年龄、性别、职称，然后再用cout语句输出职务与工资。

输入描述：
输入3个教师兼干部内容分别构造3个类
输出描述：
输出工资最高的一位教师兼干部的各项信息

# 样例输入输出
样例1
输入:
zhangsan 30 M teacher assistent 3456.2
lisi 34 M professor assistent 4589.5
wangwu 56 M professor manager 8569.5
输出:
name: wangwu
age: 56
sex: M
title: professor
post: manager
wage: 8569.5
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Teacher {
public:
    string name;
    string gender;
    int age;
    string title;

public:
    Teacher(string &amp; n, string &amp; g, int age, string &amp; t) :
        name(n), gender(g), age(age), title(t) {}

    void display() const {
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; &quot;age: &quot;  &lt;&lt; age &lt;&lt; endl;
        cout &lt;&lt; &quot;sex: &quot;  &lt;&lt; gender &lt;&lt; endl;
        cout &lt;&lt; &quot;title: &quot;&lt;&lt; title &lt;&lt; endl;
    }
};

class Cadre {
public:
    string name;
    string gender;
    int age;
    string post;
    Cadre(string &amp; n, string &amp; g, int age, string &amp; p) :
        name(n), gender(g), age(age), post(p) {}
};

class Teacher_Cadre : public Teacher, public Cadre {
public:
    double wages;

public:
    Teacher_Cadre(string &amp; n, string &amp; g, int age, string &amp; t, string &amp; p, double w) :
        Teacher(n, g, age, t), Cadre(n, g, age, p), wages(w) {}

    void show() const {
        this-&gt;Teacher::display();
        cout &lt;&lt; &quot;post: &quot; &lt;&lt; post &lt;&lt; endl;
        cout &lt;&lt; &quot;wage: &quot; &lt;&lt; wages &lt;&lt; endl;
    }
};

int main() {
    vector&lt;Teacher_Cadre&gt; people;
    string n, g, t, p; int age; double wage;
    for (int i = 0; i &lt; 3; i++) {
        cin &gt;&gt; n &gt;&gt; age &gt;&gt; g &gt;&gt; t &gt;&gt; p &gt;&gt; wage;
        people.emplace_back(Teacher_Cadre(n, g, age, t, p, wage));
    }
    // Find the highest wage.
    int ind = 0; double highest = people[0].wages;
    for (int i = 0; i &lt; people.size(); i++) {
        if (highest &lt; people[i].wages) {
            highest = people[i].wages;
            ind = i;
        }
    }
    people[ind].show();
    return 0;
}
</code></pre>
<h1 id="多态性">多态性</h1>
<pre><code class="language-Markdown"># 题目描述
完成以下代码，实现简单的计算器功能。
定义一个BaseCalculator类，包括数据成员m_A，m_B，定义成员函数为虚函数getResult()，在基类中无需实现。
定义AddCalculator，SubCalculator，MultiplicationCalculator ，DivisionCalculator为加、减、乘、除四种计算器类，继承自BaseCalculator类，并在每个类中实现getResult()方法进行不同类型的运算。
在主函数中定义一个BaseCalculator类型的指针，分别指向四种不同计算功能的四各类对象进行输出。
输入描述：输入两个整形数字m_A，m_B
输出描述：
第一行为加法结果
第二行为减法结果
第三行为乘法结果
第四行为除法结果

# 样例输入输出
样例1
输入:
6 2
输出:
8
4
12
3
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class BaseCalculator {
protected:
    int m_A;
    int m_B;
public:
    BaseCalculator(int a, int b) : m_A(a), m_B(b) {}
    virtual int getResult() {}
};

class AddCalculator : public BaseCalculator {
public:
    AddCalculator(int i, int i1) : BaseCalculator(i, i1) {}

    int getResult() override {
        return m_A + m_B;
    }
};

class SubCalculator : public BaseCalculator {
public:
    SubCalculator(int i, int i1) : BaseCalculator(i, i1) {}

    int getResult() override {
        return m_A - m_B;
    }
};

class MultiplicationCalculator : public BaseCalculator {
public:
    MultiplicationCalculator(int i, int i1) : BaseCalculator(i, i1) {}

    int getResult() override {
        return m_A * m_B;
    }
};

class DivisionCalculator : public BaseCalculator {
public:
    DivisionCalculator(int i, int i1) : BaseCalculator(i, i1) {}

    int getResult() override {
        return m_A / m_B;
    }
};

int main() {
    int a, b; cin &gt;&gt; a &gt;&gt; b;
    BaseCalculator * baseCalc;
    baseCalc = new AddCalculator(a, b);
    cout &lt;&lt; baseCalc-&gt;getResult() &lt;&lt; endl;

    baseCalc = new SubCalculator(a, b);
    cout &lt;&lt; baseCalc-&gt;getResult() &lt;&lt; endl;

    baseCalc = new MultiplicationCalculator(a, b);
    cout &lt;&lt; baseCalc-&gt;getResult() &lt;&lt; endl;

    baseCalc = new DivisionCalculator(a, b);
    cout &lt;&lt; baseCalc-&gt;getResult() &lt;&lt; endl;
}
</code></pre>
<h1 id="虚函数">虚函数</h1>
<pre><code class="language-Markdown"># 题目描述
写一个程序，定义抽象基类Shape,由他派生出3个派生类：Circle（圆类），Rectangle（矩形），Triangle（三角形）。用虚函数分别计算几种图形的面积，并求他们的和。

输入描述:
第一行为圆的半径
第二行为矩形的长，宽
第三行为三角形的底和高

输出描述：
第一行为圆形的面积
第二行为矩形的面积
第三行为三角形的面积
第四行为三个图形面积和

# 样例输入输出
样例2
输入:
2
3 4
6 8
输出:
Circlearea=12.56
Rectanglearea=12
Trianglearea=24
Area sum=48.56
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Shape {
public:
    double circleRadius{};
    double recWidth{}, recHeight{};
    double triBase{}, triHeight{};

public:
    virtual double getCircleArea() {};

    virtual double getRecArea() {};

    virtual double getTriArea() {};
};

class Circle : virtual public Shape {
public:
    double getCircleArea() override {
        return 3.14 * circleRadius * circleRadius;
    }
};

class Rectangle : virtual public Shape {
public:
    double getRecArea() override {
        return recWidth * recHeight;
    }
};

class Triangle : virtual public Shape {
public:
    double getTriArea() override {
        return 0.5 * triBase * triHeight;
    }
};

int main() {
    auto circle = new Circle();
    cin &gt;&gt; circle-&gt;circleRadius;

    auto rectangle = new Rectangle();
    cin &gt;&gt; rectangle-&gt;recWidth &gt;&gt; rectangle-&gt;recHeight;

    auto triangle = new Triangle();
    cin &gt;&gt; triangle-&gt;triBase &gt;&gt; triangle-&gt;triHeight;

    cout &lt;&lt; &quot;Circlearea=&quot; &lt;&lt; circle-&gt;getCircleArea() &lt;&lt; endl;
    cout &lt;&lt; &quot;Rectanglearea=&quot; &lt;&lt; rectangle-&gt;getRecArea() &lt;&lt; endl;
    cout &lt;&lt; &quot;Trianglearea=&quot; &lt;&lt; triangle-&gt;getTriArea() &lt;&lt; endl;
    cout &lt;&lt; &quot;Area sum=&quot; &lt;&lt; circle-&gt;getCircleArea() + rectangle-&gt;getRecArea() + triangle-&gt;getTriArea() &lt;&lt; endl;
}
</code></pre>
<h1 id="字符串a">字符串A</h1>
<pre><code class="language-Markdown"># 题目描述
利用指针实现复制一个字符串的指定位数成为一个新的字符串 。例如样例输入输出中helloNKCS中，N为第6个字符，从N开始复制N及之后的NKCS作为新字符串。

输入描述：
第一行输入 复制开始的位置  ，第二行输入一个字符串

输出描述：
从开始位置截取之后的字符串作为新字符串并输出

# 样例输入输出
样例1
输入:
6
helloNKCS
输出:
NKCS
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        int ind; cin &gt;&gt; ind;
        string s; cin &gt;&gt; s;
        for (int i = ind-1; i &lt; s.length(); i++) {
            cout &lt;&lt; s[i];
        }
    }
};

int main() {
    Solution::run();
}
</code></pre>
<h1 id="类和对象b">类和对象B</h1>
<pre><code class="language-Markdown"># 题目描述
分别定义Teacher(教师）类和Cadre（干部）类，采用多重继承方式由这两个类派生出新类Teacher_Cadre(教师兼干部)类。要求：
1、Teacher类中包含数据成员 姓名、年龄、性别、职称（title）。
2、Cadre类中包含数据成员 姓名、年龄、性别、职务（post）。
3、Teacher_Cadre类中还包含数据成员工资（wages）。
4.两个基类中的姓名、年龄、性别 数据成员用相同的名字，在引用这些数据成员时，指定作用域。
5、在派生类Teacher_Cadre 的成员函数show 中调用Teacher类中的display 函数,输出姓名、年龄、性别、职称，然后再用cout语句输出职务与工资。

输入描述：
输入3个教师兼干部内容分别构造3个类
输出描述：
输出工资最低的一位教师兼干部的各项信息，中间以空格分开

# 样例输入输出
样例1
输入:
zhangsan 30 M teacher assistent 3456.2
lisi 34 M professor assistent 4589.5
wangwu 56 M professor manager 8569.5
输出:
zhangsan 30 M teacher assistent 3456.2
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Teacher {
public:
    string name;
    string gender;
    int age;
    string title;

public:
    Teacher(string &amp; n, string &amp; g, int age, string &amp; t) :
            name(n), gender(g), age(age), title(t) {}

    void display() const {
//        cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; endl;
//        cout &lt;&lt; &quot;age: &quot;  &lt;&lt; age &lt;&lt; endl;
//        cout &lt;&lt; &quot;sex: &quot;  &lt;&lt; gender &lt;&lt; endl;
//        cout &lt;&lt; &quot;title: &quot;&lt;&lt; title &lt;&lt; endl;
        cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; gender &lt;&lt; &quot; &quot; &lt;&lt; title &lt;&lt; &quot; &quot;;
    }
};

class Cadre {
public:
    string name;
    string gender;
    int age;
    string post;
    Cadre(string &amp; n, string &amp; g, int age, string &amp; p) :
            name(n), gender(g), age(age), post(p) {}
};

class Teacher_Cadre : public Teacher, public Cadre {
public:
    double wages;

public:
    Teacher_Cadre(string &amp; n, string &amp; g, int age, string &amp; t, string &amp; p, double w) :
            Teacher(n, g, age, t), Cadre(n, g, age, p), wages(w) {}

    void show() const {
        this-&gt;Teacher::display();
//        cout &lt;&lt; &quot;post: &quot; &lt;&lt; post &lt;&lt; endl;
//        cout &lt;&lt; &quot;wage: &quot; &lt;&lt; wages &lt;&lt; endl;
        cout &lt;&lt; post &lt;&lt; &quot; &quot; &lt;&lt; wages &lt;&lt; endl;
    }
};

int main() {
    vector&lt;Teacher_Cadre&gt; people;
    string n, g, t, p; int age; double wage;
    for (int i = 0; i &lt; 3; i++) {
        cin &gt;&gt; n &gt;&gt; age &gt;&gt; g &gt;&gt; t &gt;&gt; p &gt;&gt; wage;
        people.emplace_back(Teacher_Cadre(n, g, age, t, p, wage));
    }
    // Find the highest wage.
    int ind = 0; double lowest = people[0].wages;
    for (int i = 0; i &lt; people.size(); i++) {
        if (lowest &gt; people[i].wages) {
            lowest = people[i].wages;
            ind = i;
        }
    }
    people[ind].show();
    return 0;
}
</code></pre>
<h1 id="数组排序">数组排序</h1>
<pre><code class="language-Markdown"># 题目描述
编写程序完成以下功能：
由键盘输入一系列数字组成一个数组，将改串数字从小到大进行排序操作，输出排好序的数组。

输入描述：
键盘随意输入一串数字
输出描述：
将输入的数字排序后进行输出。

# 样例输入输出
样例1
输入:
4 7 2 6 0 3 5 7 9
输出:
0 2 3 4 5 6 7 7 9
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    static void run() {
        vector&lt;int&gt; vec;
        int temp;
        while (cin &gt;&gt; temp) {
            vec.push_back(temp);
        }
        sort(vec.begin(), vec.end(), less&lt;int&gt;());
        for (int i = 0; i &lt; vec.size(); i++) {
            cout &lt;&lt; vec[i];
            if (i != vec.size()-1) cout &lt;&lt; &quot; &quot;;
        }
    }
};

int main() {
    Solution::run();
}
</code></pre>
<h1 id="附加题">附加题</h1>
<pre><code class="language-Markdown"># 题目描述
编写程序实现以下功能：
两两交换链表中的相邻节点，例如一个链表长度为4，1，2位节点进行交换，3，4位节点进行交换，输出交换后的链表。
1-&gt;2-&gt;3-&gt;4
变换为：
2-&gt;1-&gt;3-&gt;4

输入描述：
输入一系列数字代表一个链表
输出描述：
两两翻转后输出

# 样例输入输出
样例1
输入:
1 2 3 4
输出:
2 1 4 3
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct Node {
    int val;
    Node * next;
    Node() : val(0), next(nullptr) {}
    explicit Node(int v) : val(v), next(nullptr) {}
    explicit Node(int v, Node * n) : val(v), next(n) {}
} Node;

class Solution {
public:
    static void run() {
        // 根据输入构建链表
        Node * head = new Node(-1);
        int temp;
        Node * h = head;
        while (cin &gt;&gt; temp) {
            Node * node = new Node(temp);
            h-&gt;next = node;
            h = h-&gt;next;
        }

        // 两两交换相邻结点
        h = head;
        while (h &amp;&amp; h-&gt;next) {
            // 后面两个结点都存在时进行翻转
            if (h-&gt;next &amp;&amp; h-&gt;next-&gt;next) {
                Node * node1 = h-&gt;next;
                Node * node2 = h-&gt;next-&gt;next;

                node1-&gt;next = node2-&gt;next;
                h-&gt;next = node2;
                node2-&gt;next = node1;
            }
            h = h-&gt;next-&gt;next;
        }

        // 打印输出
        h = head-&gt;next;
        while (h) {
            cout &lt;&lt; h-&gt;val;
            if (h-&gt;next != nullptr) cout &lt;&lt; &quot; &quot;;
            h = h-&gt;next;
        }
    }
};

int main() {
    Solution::run();
}
</code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://eclipse-yes.github.io/tag/3tnyjqejK/">
            <span class="flex-auto">C++</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://eclipse-yes.github.io/post/SSxx8JVxj/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  Clustering in Machine Learning: k-means Algorithm
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://eclipse-yes.github.io/post/I404HkphT/">
                <h3 class="post-title">
                  Data Structure in C
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'db9fabe620a06234a7f9',
    clientSecret: '6905d50caf137022592dab848db298bc97e48f4f',
    repo: 'eclipse-yes.github.io',
    owner: 'eclipse-yes',
    admin: ['eclipse-yes'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://eclipse-yes.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
